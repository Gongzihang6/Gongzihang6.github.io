[toc]



---

### 前提：为什么需要会话跟踪？

HTTP 协议是 **无状态的 (Stateless)**。这意味着服务器不会记住你之前的任何请求。你第一次访问网站和第一万次访问，对服务器来说都是一个全新的、陌生的请求。

但这在实际应用中是行不通的。我们需要服务器能“记住”我们是谁，比如：
*   你是否已经登录？
*   你的购物车里有什么商品？
*   你的个性化设置是什么？

**会话跟踪 (Session Tracking)** 就是为了解决这个问题，让无状态的 HTTP 协议能够“记住”用户的状态。Cookie、Session 和 Token 就是实现这一目标的三种主流技术。

```mermaid
graph TD
    subgraph "问题的根源"
        A["HTTP 协议是无状态的 (Stateless)"] --> B{"服务器无法区分多次请求<br>是否来自同一个用户"};
    end

    subgraph "实际应用的需求"
        C["我们需要服务器'记住'用户状态"]
        C --> D["🛒 购物车内容"]
        C --> E["👤 登录状态"]
        C --> F["⚙️ 个性化设置"]
    end

    subgraph "解决方案：会话跟踪 (Session Tracking)"
        G["让无状态的 HTTP 协议'记住'状态"]
        G --> H["🍪<br>Cookie<br>(客户端)"]
        G --> I["🔑<br>Session<br>(服务端)"]
        G --> J["🎫<br>Token<br>(无状态)"]
    end

    B --> C;
```



---

### 1. Cookie（客户端会话跟踪）

可以把它想象成一张**咖啡店的集点卡**。

*   **原理**：服务器将少量数据（一个小的文本文件）通过 HTTP 响应头中的 `Set-Cookie` 发送给浏览器。浏览器接收到后会将其保存在本地。之后，每次该浏览器向**同一个域名**发起请求时，都会自动在 HTTP 请求头中带上这张“集点卡”（Cookie），服务器读取 Cookie 就能识别出用户。

```mermaid
graph LR
    subgraph "客户端 (Browser)"
        User("👤 用户")
    end
    subgraph "服务器 (Server)"
        Server("🖥️ 服务器")
    end

    User --"1. 首次请求 (无 Cookie)"--> Server;
    Server --"2. 响应 + <br>下发集点卡 (Set-Cookie: user_id=123)"--> User;
    User --"3. 浏览器保存<br>🍪 Cookie"--> User;
    User --"4. 后续所有请求<br>(自动携带 Cookie: user_id=123)"--> Server;
    Server --"5. 读取 Cookie<br>识别用户身份"--> Server;

    style User fill:#f9f,stroke:#333,stroke-width:2px
    style Server fill:#ccf,stroke:#333,stroke-width:2px
```

#### 过程：
1.  **首次请求**：用户（浏览器）首次访问服务器。
2.  **服务器响应与下发 Cookie**：服务器处理请求后，在响应头中加入 `Set-Cookie: user_id=123;`。
3.  **浏览器存储 Cookie**：浏览器收到响应，将 `user_id=123` 这个信息与服务器的域名关联起来，并存储在本地。
4.  **后续请求**：用户再次访问该服务器的任何页面，浏览器会自动在请求头中加入 `Cookie: user_id=123;`。
5.  **服务器识别**：服务器读取请求头中的 Cookie，就知道“哦，是用户123回来了”。

#### 优缺点：

*   **优点**：
    *   **简单**：实现非常简单，是 HTTP 协议的标准部分。
    *   **服务器无状态**：所有状态信息都存在客户端，服务器不需要存储任何会话数据，这对于服务器的水平扩展非常有利。
*   **缺点**：
    *   **不安全**：Cookie 是以明文（或简单编码）存储在客户端的，可以被用户篡改，也可以被恶意脚本（XSS 攻击）窃取。因此，**绝对不能在 Cookie 中存储敏感信息**，如密码。
    *   **大小限制**：单个 Cookie 的大小通常限制在 4KB 左右，能存储的数据量有限。
    *   **增加网络开销**：Cookie 会在每次请求时都被发送，即使是请求一张图片或一个 CSS 文件，也会带上，增加了不必要的流量。

---

### 2. Session（服务端会话跟踪，基于 Cookie）

可以把它想象成去**游泳馆寄存物品的钥匙手环**。

*   **原理**：Session 机制将用户的敏感数据和状态信息保存在**服务器端**。当用户第一次访问时，服务器会为他创建一个唯一的 Session 对象（一个储物柜），并生成一个独一无二的、随机的 **Session ID**（储物柜的钥匙）。然后，服务器将这个 Session ID 通过 Cookie 发送给客户端。客户端只需要保存这个 Session ID。之后每次请求，客户端带上这个 Session ID，服务器就能通过它找到对应的 Session 对象，从而获取用户的状态信息。

```mermaid
flowchart TD
    subgraph "客户端 (Browser)"
        A["👤 用户提交用户名/密码"]
        B{"浏览器仅存储<br>一个无意义的钥匙 🔑<br>(Session ID in Cookie)"}
    end

    subgraph "服务器 (Server)"
        D["2. 验证成功, 在服务端<br>创建 Session 对象 (储物柜)"]
        E["3. 为 Session 对象<br>生成唯一的 Session ID (钥匙)"]
        F["4. 将 Session ID 通过<br>Set-Cookie 响应头下发"]
        
        G["6. 收到后续请求<br>从中提取 Session ID"]
        H["7. 根据 Session ID<br>查找对应的 Session 对象,<br>获取用户状态"]
    end

    subgraph "服务器端存储 (如内存/Redis)"
        S1["Session 对象 1<br>{ userId: 'alice', ... }"]
        S2["Session 对象 2<br>{ userId: 'bob', ... }"]
        SID1["🔑 Session_ID_ABC"]
        SID2["🔑 Session_ID_XYZ"]
    end

    %% 定义流程
    A -- "1. 登录请求" --> D
    D --> E
    E --> F
    F -- "响应" --> B
    B -- "5. 后续请求(自动携带含Session ID的Cookie)" --> G
    
    G -.-> SID1
    G -.-> SID2
    
    H --- SID1
    H --- S2
    SID1 --> S1
    SID2 --> S2
```



#### 过程：

1.  **首次请求与登录**：用户提交用户名和密码。
2.  **服务器创建 Session**：服务器验证成功后，在服务器内存（或 Redis、数据库等）中创建一个 Session 对象，用来存储用户信息（如用户ID、角色等），并为这个 Session 对象生成一个唯一的 Session ID（例如 `JSESSIONID=ABCDEFG12345`）。
3.  **服务器下发 Session ID**：服务器将这个 Session ID 放在 `Set-Cookie` 响应头中，发送给浏览器。
4.  **浏览器存储 Session ID**：浏览器将这个 Session ID 当作一个普通的 Cookie 存储起来。
5.  **后续请求**：浏览器每次请求时，都会自动带上这个存有 Session ID 的 Cookie。
6.  **服务器查找 Session**：服务器收到请求后，从 Cookie 中拿到 Session ID，然后根据这个 ID 去自己的内存或存储中查找对应的 Session 对象，从而识别用户身份和状态。

#### 优缺点：

*   **优点**：
    *   **安全**：敏感数据都存储在服务器端，客户端只有一个无意义的 Session ID，大大降低了数据泄露和篡改的风险。
    *   **存储数据量无限制**：可以在服务器上存储任意大小和类型的数据。

*   **缺点**：
    *   **占用服务器资源**：每个用户的 Session 对象都需要在服务器上占用内存或存储空间。当用户量巨大时，服务器开销会很大。
    *   **可扩展性问题（分布式部署）**：如果应用部署在多台服务器上（集群），问题就来了：用户第一次请求被服务器 A 处理，Session 也在 A 上。第二次请求可能被负载均衡到服务器 B，但 B 上没有这个用户的 Session 信息。这就导致了“会话丢失”。
        *   **解决方案**：Session 粘滞（Sticky Session）、Session 复制、或使用**集中的 Session 存储**（如 Redis、Memcached），但这增加了架构的复杂性。

---

### 3. Token（令牌，无状态会话跟踪）

可以把它想象成一张**带有防伪标识的演唱会门票或身份证**。

*   **原理**：这是一种完全无状态的方案。用户登录成功后，服务器会生成一个加密的字符串（Token），这个 Token 本身就包含了用户信息和权限（Payload），并且有一个签名（Signature）来防止伪造。服务器不保存任何关于这个 Token 的信息。客户端收到 Token 后自己保存（通常在 `localStorage` 或 `sessionStorage` 中），并在后续的每次请求中，通过 HTTP 请求头（通常是 `Authorization`）将 Token 发送给服务器。服务器收到 Token 后，只需验证其签名是否有效，即可信任 Token 中的信息。

最流行的 Token 标准是 **JWT (JSON Web Token)**。

```mermaid
graph TD
    subgraph "客户端 (Browser/App)"
        Client("👤 客户端")
        Client -- "1. 登录请求 (用户名/密码)" --> Server;
        Client -- "3. 收到 Token 并存储<br>(localStorage/sessionStorage)" --> Storage["💾 客户端存储"];
        Storage -- "4. 后续请求 API" --> AddHeader;
        AddHeader("在请求头中携带 Token<br>Authorization: Bearer <token>") -- "5. 发送请求" --> Server;
    end

    subgraph "服务器 (Stateless Server)"
        Server("🖥️ 服务器")
        Server -- "2. 验证成功, 生成并下发<br>🎫 Token (包含用户信息和签名)" --> Client;
        Server -- "6. 收到 Token" --> Verify["7. 验证 Token 签名<br> (使用密钥)"];
        Verify -- "签名有效 ✅" --> Process["8. 信任 Token 中的信息, 处理请求"];
        Verify -- "签名无效/过期 ❌" --> Deny["9. 拒绝请求"];
    end
    
    style Server fill:#ccf,stroke:#333,stroke-width:2px
    style Client fill:#f9f,stroke:#333,stroke-width:2px
    style Verify fill:#b2f7b2
    style Deny fill:#f7b2b2
```

#### 过程：
1.  **登录请求**：用户发送用户名和密码。
2.  **服务器生成并下发 Token**：服务器验证成功，将用户的 ID、角色、过期时间等信息作为“有效载荷(Payload)”，加上一些元数据（Header），然后用一个**服务器端私有的密钥 (Secret)** 对这两部分进行**签名**，生成一个完整的 Token 字符串。服务器将这个 Token 作为响应体返回给客户端。
3.  **客户端存储 Token**：客户端的 JavaScript 代码获取到 Token，并将其存储在 `localStorage` 或 `sessionStorage` 中。
4.  **后续请求**：客户端每次请求需要认证的 API 时，都会在 HTTP 请求头的 `Authorization` 字段中携带这个 Token，格式通常是 `Authorization: Bearer <token>`。
5.  **服务器验证 Token**：服务器收到请求，提取出 Token。它使用相同的密钥和算法来验证 Token 的签名。
    *   如果签名验证通过，说明 Token 未被篡改，服务器就信任其中的用户信息，并处理请求。
    *   如果签名验证失败，或 Token 已过期，服务器就拒绝请求。

#### 优缺点：

*   **优点**：
    *   **无状态与可扩展性**：服务器完全不存储会话信息，减轻了服务器的压力。任何一台服务器只要拥有相同的密钥，就能验证 Token，非常适合分布式、微服务架构。
    *   **跨域友好**：不受 Cookie 同源策略的限制，可以轻松地用于任何域名的 API 服务。
    *   **支持多种客户端**：无论是 Web 浏览器、移动 App 还是其他服务，都可以使用统一的 Token 认证方案。
    *   **性能好**：验证 Token 只是一个计算过程，不需要查询数据库或缓存，性能较高。

*   **缺点**：
    *   **难以主动失效**：一旦签发，Token 在其有效期内就一直有效。如果用户中途想“退出登录”或管理员想“强制下线”某个用户，服务器端很难主动让这个 Token 失效。常规解决方案是引入黑名单机制，但这又破坏了“无状态”的初衷。
    *   **占用带宽**：JWT Token 通常比 Session ID 要长，每次请求都携带会增加一点网络开销。
    *   **安全性**：如果 Token 存储在 `localStorage` 中，容易受到 XSS 攻击的威胁，攻击者可以窃取 Token。因此需要做好 XSS 防护。

---

### 总结与对比

| 特性             | Cookie                     | Session (基于Cookie)                   | Token (JWT)                            |
| ---------------- | -------------------------- | -------------------------------------- | -------------------------------------- |
| **数据存储位置** | 客户端浏览器               | 服务器端                               | 客户端（Token本身包含数据）            |
| **状态性**       | 无状态 (服务器不存)        | 有状态 (服务器需保存Session)           | 无状态 (服务器不存)                    |
| **安全性**       | 低（明文，易被窃取和篡改） | 高（数据在服务端，客户端只有无意义ID） | 较高（有签名防篡改，但需防XSS窃取）    |
| **可扩展性**     | 好                         | 差（集群部署需额外处理Session共享）    | 极好（天然支持分布式和微服务）         |
| **跨域支持**     | 差（受同源策略限制）       | 差（基于Cookie，同样受限）             | 好（通过Header传输，无跨域问题）       |
| **适用场景**     | 存储不敏感信息，如“记住我” | 传统的、单体架构的 Web 应用            | 前后端分离、微服务、移动App、第三方API |





### JWT 是怎么产生的？

JWT 的生成过程可以理解为**“制作一张不可伪造的数字身份证”**。这张身份证由三个部分拼接而成，每个部分都承担着不同的职责。

一个典型的 JWT 看起来是这样的，由两个点 `.` 分隔成三段：

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJyb2xlcyI6WyJBRE1JTiIsIlVTRVIiXX0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`

这三段分别是：

1.  **Header (头部)**
2.  **Payload (载荷)**
3.  **Signature (签名)**

下面我们逐步解析这三个部分的生成过程：

---

```mermaid
graph LR
    subgraph "完整的 JWT (三部分由 . 连接)"
        JWT["eyJ...<br><b>Header</b>.eyJ...<br><b>Payload</b>.Sfl...<br><b>Signature</b>"]
    end

    subgraph "1. Header (头部)"
        Header_JSON["{<br>  'alg': 'HS256',<br>  'typ': 'JWT'<br>}"]
        Header_Note("说明书：<br>类型和签名算法")
        Header_JSON -- "Base64Url 编码" --> Header_Encoded["eyJ..."]
    end

    subgraph "2. Payload (载荷)"
        Payload_JSON["{<br> 'sub': 'user123',<br> 'roles': ['USER'],<br> 'exp': 1668859022<br>}"]
        Payload_Note("核心信息：<br>用户数据、权限、过期时间<br><b>🚫绝不放敏感信息</b>")
        Payload_JSON -- "Base64Url 编码" --> Payload_Encoded["eyJ..."]
    end

    subgraph "3. Signature (签名)"
        Secret["🔒 服务器私有密钥 (Secret)"]
        Input["Header(编码) + '.' + Payload(编码)"]
        Signature_Note("防伪印章：<br>证明信息未被篡改")
        Input -- "使用 alg 定义的算法<br>和 Secret 进行加密" --> Signature_Encoded["Sfl..."]
        Secret --> Signature_Encoded
    end

    Header_Encoded --"."--> JWT
    Payload_Encoded --"."--> JWT
    Signature_Encoded --> JWT
```



#### 1. Header (头部) - 身份证的类型说明

头部通常包含两部分信息：
*   `typ` (Type): 令牌的类型，固定为 "JWT"。
*   `alg` (Algorithm): 使用的签名算法，例如 `HS256` (表示 HMAC-SHA256) 或 `RS256` (表示 RSA-SHA256)。

**生成步骤:**
将上述信息表示为一个 JSON 对象：
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
然后，对这个 JSON 字符串进行 **Base64Url** 编码，得到 JWT 的第一部分。
`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

> **注意**: Base64Url 是一种编码方式，不是加密。任何人都可以将这段编码解码，看到里面的内容。

---

#### 2. Payload (载荷) - 身份证的核心信息

载荷是 JWT 的核心，用于存放实际需要传递的数据，这些数据被称为“声明 (Claims)”。声明分为三类：

*   **注册声明 (Registered Claims)**: 这些是标准化的、建议使用的声明，但并非强制。常见的有：
    *   `iss` (Issuer): 签发者
    *   `sub` (Subject): 主题，通常是用户的唯一标识（如用户ID）。
    *   `aud` (Audience): 接收者
    *   `exp` (Expiration Time): **过期时间**。这是保障安全的关键！
    *   `iat` (Issued At): 签发时间
*   **公共声明 (Public Claims)**: 可以添加任何信息，但为了避免冲突，名称应在 IANA JSON Web Token Registry 中注册或使用包含命名空间的 URI。
*   **私有声明 (Private Claims)**: 这是我们自定义的声明，用于在客户端和服务器之间共享信息。例如：
    *   `userId`: 用户ID
    *   `username`: 用户名
    *   `roles`: 用户角色列表
    *   `authorities`: 用户权限列表

**生成步骤:**
将所有声明组合成一个 JSON 对象：
```json
{
  "sub": "user123",
  "username": "alice",
  "roles": ["USER"],
  "iat": 1668855422,
  "exp": 1668859022
}
```
同样，对这个 JSON 字符串进行 **Base64Url** 编码，得到 JWT 的第二部分。

> **再次强调**: 载荷部分也是**公开**的！**绝对不要在载荷中存放任何敏感信息，例如用户的密码！**

---

#### 3. Signature (签名) - 身份证的防伪印章

签名是保障 JWT 安全性的**最核心**部分。它的作用是**验证令牌的完整性**，确保前两部分（头部和载荷）在传输过程中没有被篡改。

**生成步骤:**
签名是通过将编码后的头部、编码后的载荷、一个**密钥 (Secret)** 和头部指定的签名算法 (`alg`) 结合生成的。

公式如下：
```
Signature = HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```
过程分解：
1.  将编码后的 Header 和编码后的 Payload 用一个点 `.` 连接起来。
2.  使用在 Header 中定义的签名算法（如 `HS256`），以一个**只有服务器知道的密钥 (`secret`)** 对这个连接后的字符串进行哈希计算。
3.  将计算出的哈希值进行 **Base64Url** 编码，就得到了 JWT 的第三部分。

最后，将这三部分用 `.` 连接起来，一个完整的 JWT 就诞生了。

### JWT 如何确保安全？

```mermaid
graph TD
    A("🔒 JWT 安全体系")

    subgraph "防篡改 (Integrity)"
        B["🖋️ <b>签名 (Signature)</b>"]
        B_Desc("服务器用密钥验证签名<br>确保 Header 和 Payload 未被修改")
    end

    subgraph "防伪造 (Authenticity)"
        C["🔑 <b>密钥保密 (Secret)</b>"]
        C_Desc("密钥绝不外泄<br>只有真正的服务器才能签发有效 Token")
    end

    subgraph "防滥用 (Timeliness)"
        D["⏱️ <b>设置过期时间 (exp)</b>"]
        D_Desc("即使 Token 被盗<br>其有效期也极短, 降低风险")
    end

    subgraph "防窃听 (Confidentiality)"
        E["🛡️ <b>HTTPS 传输</b>"]
        E_Desc("加密整个通信通道<br>防止 Token 在传输过程中被截获")
    end

    A --> B
    A --> C
    A --> D
    A --> E
```

JWT 的安全性并非来自信息加密，而是来自**签名机制**和一系列**最佳实践**。

#### 1. 防篡改 (Integrity) - 签名的核心价值

这是 JWT 最核心的安全保障。
*   **工作原理**: 当服务器收到一个 JWT 时，它会用**自己本地保存的同一个密钥 (`secret`)**，对接收到的 Header 和 Payload 执行与生成时完全相同的签名计算。
*   **验证**: 然后，服务器会将新计算出的签名与 JWT 中自带的第三部分（签名）进行比对。
    *   如果两者**完全一致**，说明数据是可信的，从签发到现在没有被任何人修改过。
    *   如果**不一致**，说明 Header 或 Payload 在传输过程中被恶意篡改，服务器会立即拒绝该请求。

**举例**: 一个攻击者截获了你的 JWT，他可以轻易地解码 Payload，将里面的 `"roles": ["USER"]` 修改为 `"roles": ["ADMIN"]`。但是，他没有服务器的 `secret`。当他用修改后的 Payload 重新编码并发送请求时，服务器的验证会失败，因为用原始 `secret` 对被篡改的数据计算出的签名，与他伪造的 JWT 自带的旧签名完全不同。

#### 2. 密钥的保密性 (Confidentiality of the Secret)

整个签名机制的安全性都建立在**密钥 (`secret`) 的绝对保密**之上。
*   **对称加密 (如 HS256)**: 签发和验证使用同一个密钥。这个密钥必须被妥善保管在服务器端，绝不能泄露到客户端或任何不安全的地方。一旦密钥泄露，攻击者就能随意签发有效的 JWT。
*   **非对称加密 (如 RS256)**: 使用**私钥**进行签名，使用对应的**公钥**进行验证。这种方式更安全，因为你可以安全地将公钥分发给其他服务（例如资源服务器），让它们能够验证 JWT，而无需暴露能够签发 JWT 的私钥。这在微服务架构中非常有用。

#### 3. 设置过期时间 (`exp` Claim)

这是防止令牌滥用的关键一环。
*   **必须设置 `exp`**: 务必为每个 JWT 设置一个合理的、较短的过期时间（例如 15 分钟、1 小时）。
*   **作用**: 即使一个 JWT 令牌被盗，它的有效期也非常有限，大大降低了风险。攻击者只能在这段短暂的时间内使用它。
*   **续期**: 为了提升用户体验，通常会采用**短期的 Access Token** 和**长期的 Refresh Token** 组合的策略。当 Access Token 过期后，客户端可以使用 Refresh Token 去申请一个新的 Access Token，而无需用户重新登录。

#### 4. 使用 HTTPS 进行传输

JWT 本身不加密内容，所以它在网络中传输时是“裸奔”的。
*   **必须使用 HTTPS**: 所有 API 请求都必须通过 HTTPS 进行。HTTPS/TLS 会加密整个通信通道，防止中间人攻击者嗅探到 `Authorization` 请求头中的 JWT 令牌。如果使用 HTTP，任何人都能截获令牌并重放攻击。

#### 总结：JWT 安全备忘录

| 安全措施                  | 目的                                   | 如果不做会怎样？                                             |
| :------------------------ | :------------------------------------- | :----------------------------------------------------------- |
| **签名 (Signature)**      | **防篡改**，保证数据完整性             | 任何人都可以修改你的用户信息（如角色、ID）来非法提权。       |
| **保密密钥 (Secret Key)** | **身份认证**，确保令牌是由可信方签发的 | 密钥泄露等于“万能钥匙”被盗，攻击者可以伪造任何用户的身份。   |
| **设置过期时间 (`exp`)**  | **时效性**，限制令牌被盗后的危害       | 令牌一旦被盗，将永久有效，攻击者可以一直冒充用户身份。       |
| **HTTPS 传输**            | **防窃听**，保护令牌在传输过程中的安全 | 在不安全的网络（如公共Wi-Fi）下，令牌可以被轻易截获并用于重放攻击。 |
| **不在载荷中存敏感信息**  | **信息脱敏**，避免敏感数据泄露         | 用户密码、银行卡号等关键信息会以明文形式暴露给任何能解开令牌的人。 |