## Q1. 偶数的按位或运算

简单 3 分

给你一个整数数组 `nums`。返回数组中所有 **偶数** 的按位 **或** 运算结果。如果 `nums` 中没有偶数，返回 0。

 示例 1：

```
输入： nums = [1,2,3,4,5,6]

输出： 6

解释：偶数为 2、4 和 6。它们的按位或运算结果是 6。
```

示例 2：

```
输入： nums = [7,9,11]

输出： 0

解释：数组中没有偶数，因此结果为 0。
```

示例 3：

```
输入： nums = [1,8,16]

输出： 24

解释：偶数为 8 和 16。它们的按位或运算结果是 24。
```

提示：

-   1 <= nums.length <= 100
-   1 <= nums [i] <= 100

### 我的思路

题目要求返回数组中所有 **偶数** 的 **按位或** 运算的结果，由于如果数组 `nums` 中没有偶数，则返回 0，所以初始化时可以先定义一个 `result = 0`，因为任何数和 0 按位或都是它本身，不会有任何改变。所以我们可以遍历 `nums` 中的每个元素，

-   如果当前元素是偶数，则将当前元素和 `result` 进行按位或运算，并保留赋值给 `result`，通过 `result` 记录所有偶数按位或运算的结果；
-   如果当前元素是奇数，则直接跳过，什么也不用做。

Java 实现代码如下：

```java
class Solution {
    public int evenNumberBitwiseORs(int[] nums) {
        int n = nums.length;
        int result = 0;
        for(int i=0;i<n;i++){
            if(nums[i]%2==0){
                result = result | nums[i];
            }
        }
        return result;
    }
}
```



## Q2. 最大子数组总值 I

中等 4 分
给定一个长度为 `n` 的整数数组 `nums` 和一个整数 `k`。你必须从 `nums` 中选择 恰好 `k` 个非空子数组 `nums[l..r]`。子数组可以重叠，同一个子数组（相同的 `l` 和 `r`）可以 被选择超过一次。

子数组 `nums[l..r]` 的 值 定义为：`max(nums[l..r]) - min(nums[l..r])`。

总值 是所有被选子数组的 值 之和。返回你能实现的 最大 可能总值。

子数组 是数组中连续的 非空 元素序列。


示例 1:

```
输入: nums = [1,3,2], k = 2

输出: 4

解释:一种最优的方法是：

选择 nums[0..1] = [1, 3]。最大值为 3，最小值为 1，得到的值为 3 - 1 = 2。
选择 nums[0..2] = [1, 3, 2]。最大值仍为 3，最小值仍为 1，所以值也是 3 - 1 = 2。
将它们相加得到 2 + 2 = 4。
```

示例 2:

```
输入: nums = [4,2,5,1], k = 3

输出: 12

解释:一种最优的方法是：

选择 nums[0..3] = [4, 2, 5, 1]。最大值为 5，最小值为 1，得到的值为 5 - 1 = 4。
选择 nums[1..3] = [2, 5, 1]。最大值为 5，最小值为 1，所以值也是 4。
选择 nums[2..3] = [5, 1]。最大值为 5，最小值为 1，所以值同样是 4。
将它们相加得到 4 + 4 + 4 = 12。
```

提示:

-   1 <= n == nums.length <= 5 * 10^4
-   0 <= nums [i] <= 10^9
-   1 <= k <= 10^5



### 我的思路：

这里子数组的值就是子数组中最大值和最小值之差，也就是极差 range，既然题目说了子数组可以重叠，而且同一个子数组（相同的 `l` 和 `r`）可以被选择超过一次，所以单个子数组的值可以取到的最大值就是原始数组的极差，子数组可以重叠，就直接将包含原始数组极差（也就是包含原始数组的最小值和最大值）的子数组选择 `k` 次就可以实现最大可能总值。

关键在于要找到原始数组 `nums` 中的最大值和最小值，且必须在一次遍历内找到，这里居然不会:grimacing:

实现步骤如下：

1.  在输入的数组 `nums` 中找到全局最大值 `maxVal` 和全局最小值 `minVal`。（通过一次遍历找到）
2.  计算单个子数组能产生的最大值：`diff = maxVal - minVal`。
3.  这个最大值乘以 `k` 就是我们能得到的最大可能总值。
4.  需要注意数据范围：`nums[i]` 最大为 $10^9$，`k` 最大为 $10^5$。两者的乘积可能会超过 `int` 类型的最大值 (约 2 * 10^9)，因此计算总值时需要使用 `long` 类型以防止溢出。

Java 实现代码如下：

```java
import java.util.Arrays;

class Solution {
    /**
     * 计算k个子数组的最大可能总值。
     *
     * @param nums 整数数组
     * @param k    选择的子数组数量
     * @return 最大可能总值
     */
    public long maxTotalValue(int[] nums, int k) {
       
        // 如果数组长度小于等于1，任何子数组的最大值和最小值都相同，
        // 因此值为0，总值也为0。
        if (nums.length <= 1) {
            return 0;
        }

        // 步骤 1: 找到整个数组中的最大值和最小值。
        // 初始化最大值和最小值为数组的第一个元素。
        int minVal = nums[0];
        int maxVal = nums[0];

        // 遍历数组，从第二个元素开始，更新最大值和最小值。
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < minVal) {
                minVal = nums[i];
            }
            if (nums[i] > maxVal) {
                maxVal = nums[i];
            }
        }
        
        /*
         * Java 8 Stream API 的替代写法:
         * int minVal = Arrays.stream(nums).min().getAsInt();
         * int maxVal = Arrays.stream(nums).max().getAsInt();
         */

        // 步骤 2: 计算单个子数组能产生的最大值。
        // 这个值等于整个数组的最大值减去最小值。
        // 我们需要将结果转换为 long 类型以防止后续乘法溢出。
        long bestSingleValue = (long) maxVal - minVal;

        // 步骤 3: 计算总值。
        // 最优策略是每次都选择能产生最大值的子数组，共选择k次。
        long totalMaxValue = bestSingleValue * k;

        return totalMaxValue;
    }
}
```



## Q3. 拆分合并数组

中等 5 分
给你两个长度为 n 的整数数组 nums1 和 nums2。你可以对 nums1 执行任意次下述的 拆分合并操作：

-   选择一个子数组 nums1 [L..R]。
-   移除该子数组，留下前缀 nums1 [0..L-1]（如果 L = 0 则为空）和后缀 nums1 [R+1..n-1]（如果 R = n - 1 则为空）。
-   将移除的子数组（按原顺序）重新插入到剩余数组的 任意 位置（即，在任意两个元素之间、最开始或最后面）。

返回将 nums1 转换为 nums2 所需的 最少拆分合并操作 次数。

 

示例 1:

```
输入: nums1 = [3,1,2], nums2 = [1,2,3]

输出: 1

解释:

拆分出子数组 [3] (L = 0, R = 0)；剩余数组为 [1,2]。
将 [3] 插入到末尾；数组变为 [1,2,3]。
```

示例 2:

```
输入: nums1 = [1,1,2,3,4,5], nums2 = [5,4,3,2,1,1]

输出: 3

解释:

移除下标 0 - 2 处的 [1,1,2]；剩余 [3,4,5]；将 [1,1,2] 插入到位置 2，得到 [3,4,1,1,2,5]。
移除下标 1 - 3 处的 [4,1,1]；剩余 [3,2,5]；将 [4,1,1] 插入到位置 3，得到 [3,2,5,4,1,1]。
移除下标 0 - 1 处的 [3,2]；剩余 [5,4,1,1]；将 [3,2] 插入到位置 2，得到 [5,4,3,2,1,1]。
```


提示:

-   2 <= n == nums1.length == nums2.length <= 6
-   -10^5 <= nums1[i], nums2[i] <= 10^5
-   nums2 是 nums1 的一个 排列。

#### 1. 问题建模：状态空间搜索

这个问题的核心是找到从一个数组状态（`nums1`）转变到另一个数组状态（`nums2`）所需的最少操作次数。这可以被建模为一个 **最短路径问题**。

-   **状态（节点）**: 数组的每一种可能的排列（permutation）都是一个状态。
-   **操作（边）**: <span style="background:#6fe7dd;">从一个状态到另一个状态的“拆分合并”操作就是一条边。</span>由于我们关心的是最少次数，可以认为每条边的权重都是 1。
-   **目标**: 找到从初始状态 `nums1` 到目标状态 `nums2` 的最短路径。

对于求解无权图中的最短路径问题，**广度优先搜索（BFS）**是最经典的算法。

#### 2. 广度优先搜索 (BFS) 策略

BFS 的思想是从起点开始，一层一层地向外探索。

-   第 0 层：只有起始数组 nums1。
-   第 1 层：所有可以从 nums1 通过 **1 次** 拆分合并操作得到的**数组**。
-   第 2 层：所有可以从第 1 层的数组通过 **1 次** 操作得到的、且之前未访问过的新数组。
-   ...依此类推。

**我们不断地探索，直到在某一层中找到了目标数组 nums2。此时，所在的层数就是所需的最少操作次数。**

#### 3. 算法具体步骤

1.  **初始化**: 创建一个队列 `queue` 用于存放待访问的状态（数组的一个排列）。创建一个集合 `visited` 用于记录已经访问过的状态，防止重复计算和无限循环。将初始状态 `nums1` 转换为 `List <Integer>`（因为 List 可以方便地用在集合和队列中，且自带 equals 和 hashCode 方法），然后加入队列 `queue` 和 `visited` 集合。设置操作次数 `operations = 0`。

2.  **特殊情况**: 首先检查 `nums1` 是否已经和 `nums2` 相等。如果是，则不需要任何操作，直接返回 0。

3.  **BFS 循环**: <span style="color:#d59bf6;">当队列不为空时，进行循环。</span>在每一轮循环开始时，我们处理当前层的所有节点。先记录下当前队列的大小 `levelSize`。将操作次数 `operations` 加 1。循环 `levelSize` 次，处理当前层的所有状态：

    a. 从队列中取出一个状态 `current_array`。
    b. **生成下一个状态**: 从 `current_array` 生成**所有可能通过一次拆分合并操作得到的新数组**。这个过程如下：
    	i. 遍历所有可能的子数组 [L..R]。
    	ii. 对于每一个子数组，将其从 current_array 中“移除”，得到一个 remaining_array。
    	iii. 遍历 remaining_array 的所有可能插入点（包括最前和最后），将子数组插入，形成一个 new_array。
    c. **检查和更新**: 对于每一个生成的 new_array：
    	i. 如果 new_array 等于目标 nums2，说明我们找到了最短路径，立即返回当前的 operations 值。
    	ii. 如果 new_array 还没有被访问过（即不在 visited 集合中），则将其加入 visited 集合，并放入队列 queue 中，等待下一层处理。

4.  **约束提示**: 题目中 n <= 6 是一个非常重要的提示。这意味着状态空间（所有可能的排列）很小（最多 6! = 720），所以即使 BFS 的复杂度较高，也完全可以接受。

Java实现代码如下：

```java
import java.util.*;
import java.util.stream.Collectors;

class Solution {
    public int minSplitMerge(int[] nums1, int[] nums2) {

        List<Integer> startList = Arrays.stream(nums1)
                                .boxed()
                                .collect(Collectors.toList());
        List<Integer> targetList = Arrays.stream(nums2)
                                .boxed()
                                .collect(Collectors.toList());

        // 如果初始状态就等于目标状态，不需要操作。
        if (startList.equals(targetList)) {
            return 0;
        }

        // BFS 使用的队列和防止重复访问的集合
        Queue<List<Integer>> queue = new LinkedList<>();
        Set<List<Integer>> visited = new HashSet<>();

        // 初始化
        queue.offer(startList);
        visited.add(startList);

        int operations = 0;

        while (!queue.isEmpty()) {
            // operations 递增，代表 BFS 的层数
            operations++;
            int levelSize = queue.size();

            // 遍历当前层的所有节点
            for (int i = 0; i < levelSize; i++) {
                List<Integer> currentList = queue.poll();

                // 从当前状态生成所有可能的下一个状态
                // 1. 遍历所有可能的子数组 [L..R]
                for (int l = 0; l < currentList.size(); l++) {
                    for (int r = l; r < currentList.size(); r++) {
                        
                        // 提取子数组和剩余部分
                        List<Integer> subArray = new ArrayList<>(currentList.subList(l, r + 1));
                        List<Integer> remaining = new ArrayList<>();
                        for (int j = 0; j < l; j++) {
                            remaining.add(currentList.get(j));
                        }
                        for (int j = r + 1; j < currentList.size(); j++) {
                            remaining.add(currentList.get(j));
                        }

                        // 2. 遍历所有可能的插入位置
                        for (int insertPos = 0; insertPos <= remaining.size(); insertPos++) {
                            List<Integer> nextState = new ArrayList<>(remaining);
                            nextState.addAll(insertPos, subArray);

                            // 检查是否达到目标
                            if (nextState.equals(targetList)) {
                                return operations;
                            }

                            // 如果是未访问过的新状态，则加入队列和 visited 集合
                            // 如果是访问过的状态，则可以直接跳过，因为已经知道不等于目标targetList
                            if (!visited.contains(nextState)) {
                                visited.add(nextState);
                                queue.offer(nextState);
                            }
                        }
                    }
                }
            }
        }
        
        // 理论上因为 nums2 是 nums1 的排列，所以总能找到解，不会到达这里。
        return -1; 
    }
}
```



## Q4. 最大子数组总值 II

困难 7 分
给你一个长度为 `n` 的整数数组 `nums` 和一个整数 `k`。你必须从 `nums` 中选择 恰好 k 个 **不同** 的非空子数组 `nums[l..r]`。子数组可以重叠，但同一个子数组（相同的 l 和 r）不能 被选择超过一次。

子数组 `nums[l..r]` 的 值 定义为：`max(nums[l..r]) - min(nums[l..r])`。

总值 是所有被选子数组的 值 之和。返回你能实现的 最大 可能总值。

子数组 是数组中连续的 非空 元素序列。

**示例 1:**

```
输入: nums = [1,3,2], k = 2

输出: 4

解释:

一种最优的方法是：

选择 nums[0..1] = [1, 3]。最大值为 3，最小值为 1，得到的值为 3 - 1 = 2。
选择 nums[0..2] = [1, 3, 2]。最大值仍为 3，最小值仍为 1，所以值也是 3 - 1 = 2。
将它们相加得到 2 + 2 = 4。
```

**示例 2:**

```
输入: nums = [4,2,5,1], k = 3

输出: 12

解释:

一种最优的方法是：

选择 nums[0..3] = [4, 2, 5, 1]。最大值为 5，最小值为 1，得到的值为 5 - 1 = 4。
选择 nums[1..3] = [2, 5, 1]。最大值为 5，最小值为 1，所以值也是 4。
选择 nums[2..3] = [5, 1]。最大值为 5，最小值为 1，所以值同样是 4。
将它们相加得到 4 + 4 + 4 = 12。
```

 

提示:

-   1 <= n == nums.length <= 5 * 10^4
-   0 <= nums [i] <= 10^9
-   1 <= k <= min(10^5, n * (n + 1) / 2)



### 一、核心思路（直观＋关键观察）

目标：从数组 `nums` 的所有子数组（共有 n*(n+1)/2 个）中选出恰好 `k` 个不同子数组，使它们的值之和最大。子数组的“值”定义为：`val(l, r) = max(nums[l..r]) - min(nums[l..r])`

关键观察与结论：

1.  **对固定左端 l，val(l, r) 随 r 单调不减**。
     理由：当 r 增大时，区间的最大值不会减小，最小值不会增大，因此差值 max - min 不会减。
     所以对于同一左端 l，有序序列：
     `val(l, l) ≤ val(l, l+1) ≤ ... ≤ val(l, n-1)`
2.  因此我们可以把每个左端 `l` 看成一条“已排序的序列”（按 r 从小到大是**非减**；如果我们按 r 从大到小考虑就是非增序列）。求“所有行的全局前 k 大值”可以用 **k-way merge（多路合并）** 的方法：<span style="color:#d59bf6;">把每条序列的当前最大候选放入大根堆，每次取出堆顶（当前全局最大），然后把**同一行**的下一个候选（r 向左移一位）放入堆。重复 k 次即可得到前 k 大元素。</span>
3.  为了能在 O(1) 时间内算出任意子数组 [l,r] 的 val（因为堆中需要频繁计算 val），我们使用 **稀疏表（Sparse Table）** 预处理区间最大值和最小值。稀疏表建表 O(n log n)，查询 O(1)。

**综合：建表 O(n log n) + 用堆取 k 个 O(k log n) ⇒ 总复杂度 O(n log n + k log n)。**

### 二、正确性说明（更严谨）

-   在任意时刻，堆中包含每条序列（即每个 l）**当前尚未被选取的最大元素**（一开始是 r = n-1）。因此堆顶是当前全局最大未取元素 —— 弹出它是安全的（可以得到当前未取元素中最大者）。弹出后从**该行**推入该行的下一个最大（r-1），**继续保证堆里仍然保有每条序列的最大候选**。重复 k 次就能得到全局前 k 大。
-   每个 (l,r) 被推入堆至多一次，因此不会重复选同一个子数组。
-   用稀疏表查询区间最大值/最小值是正确且 O(1) 的。

### 三、实现流程（逐步）

#### 1) 准备与边界处理

-   读入 `int[] nums`，`int n = nums.length`，以及 `int k`。
-   若 n == 0 或 k == 0，直接返回 0（没有子数组或不需要选择）。

#### 2) 计算需要的稀疏表层数 LOG

-   令 `LOG = floor(log2(n)) + 1`。简单实现方式：
     LOG = 1; while ((1 << LOG) <= n) LOG++;
     这样 LOG 最终满足 2^(LOG-1) <= n < 2^LOG。

#### 3) 构建两个稀疏表 stMax 与 stMin

-   stMax 是 `int[LOG][n]`，stMin 同理。
-   初始化：`stMax[0][i] = nums[i]`，`stMin[0][i] = nums[i]`。
-   对 j 从 1 到 LOG-1：
    -   len = 1 << j, half = 1 << (j-1)
    -   对 i 从 0 到 n - len：
        -   stMax[j][i] = max(stMax[j-1][i], stMax[j-1][i + half])
        -   stMin[j][i] = min(stMin[j-1][i], stMin[j-1][i + half])

说明：第 j 层记录长度为 2^j 的区间的最大/最小。

#### 4) 预计算对数表 lg[]，便于查询

-   `lg[x] = floor(log2(x))`，x 从 1..n。
-   实现：lg[1] = 0; for i=2..n: lg[i] = lg[i>>1] + 1;

#### 5) 实现 range query 函数：rangeValue(l, r)

-   len = r - l + 1; j = lg[len];
-   区间 [l, r] 可被两个长度为 2^j 的块覆盖：`[l, l+2^j-1]` 与 `[r-2^j+1, r]`。
-   max = max(stMax[j][l], stMax[j][r - (1<<j) + 1]);
-   min = min(stMin[j][l], stMin[j][r - (1<<j) + 1]);
-   返回 (long) max - (long) min。

（返回 long 是为了在累加时避免溢出。）

#### 6) 用大根堆（PriorityQueue）做多路合并

-   定义堆元素 Node：包含 (long val, int l, int r)。
-   初始：对每个 l 从 0 到 n-1，计算 v = rangeValue(l, n-1)，并把 Node(v,l,n-1) 入堆。理由：每行最大的候选是 r = n-1。
-   循环 k 次或直到堆空：
    -   pop 一个 Node cur（堆顶，全局当前最大）。
    -   ans += cur.val。
    -   如果 cur.r > cur.l（说明该行还有次大候选），计算 next = rangeValue(cur.l, cur.r-1)，入堆 Node(next, cur.l, cur.r-1)。
-   循环结束返回 ans。

#### 7) 注意点

-   使用 long 保存答案与 Node.val。
-   如果 k 比子数组总数还大（题目通常保证不会，但你的实现应保险处理），堆空时就提前终止。
-   稀疏表用了 O(n log n) 空间，n<=5e4 时通常可接受（下面有内存估算）。

### 四、复杂度与内存估算（精确）

-   构建稀疏表：每层做 O(n) 合并，层数 ≈ floor(log2(n)) + 1 => 时间 O(n log n)。
-   初始化堆插入 n 个元素：每次插入是 O(log n)（堆大小最多 n），但初始化 n 次也在 O(n log n)；实际上 Java 的 PriorityQueue 插入 n 次成本 O(n log n)，但占主导的仍是 k 次弹出/入堆阶段。
-   主循环：最多执行 k 次 pop（每次 O(log n)），并可能执行最多 k 次 push（每次 O(log n)） ⇒ O(k log n)。
-   总时间：O(n log n + k log n)。

空间：

-   stMax 占用 LOG * n ints，stMin 同样。若 n = 5×10^4，LOG = 16（因为 2^15=32768 < 50000 < 2^16），条目数 = 16*50000 = 800k，每个 int 4 字节 => 3.2MB/表，两个表约 6.4MB。再加上堆与 Java 数组开销、对象开销，总共 << 100MB，通常可接受。

### 五、为什么要在弹出后把 r-1 入堆（再强调一次）

-   因为虽然 val(l,n-1) 是该行最大，但全局前 k 大可能包括来自同一行的多个值（例如 val(l,n-2)、val(l,n-3)）。如果只把每行的最大压入堆，就永远失去同一行的次大候选 —— 这将漏掉真正的大值。多路合并每次从被取出的行继续推进，能保证每行的所有候选按次序延伸进入全局竞争，从而正确取到前 k 大。

### 六、示例：堆的运行演示（两个例子）

下面逐步把堆里元素写出来，便于直观理解“弹出 + 推入 r-1” 的流程。

#### 示例 A：nums = [4, 2, 5, 1], k = 3（前文示例）

n = 4
 计算每行 r = n-1 的值：

-   l=0, r=3: val = max(4,2,5,1) - min(...) = 5 - 1 = 4
-   l=1, r=3: val = 5 - 1 = 4
-   l=2, r=3: val = 5 - 1 = 4
-   l=3, r=3: val = 1 - 1 = 0

初始堆（按 val 从大到小）：
 [(4,0,3), (4,1,3), (4,2,3), (0,3,3)]

步骤：

1.  pop (4,0,3) -> ans = 4. push (l=0,r=2): val(0,2)=max(4,2,5)-min(4,2,5)=5-2=3
     堆 => [(4,1,3),(4,2,3),(3,0,2),(0,3,3)]
2.  pop (4,1,3) -> ans = 8. push (1,2): val(1,2)=max(2,5)-min=5-2=3
     堆 => [(4,2,3),(3,0,2),(3,1,2),(0,3,3)]
3.  pop (4,2,3) -> ans = 12. push (2,2): val(2,2)=5-5=0
     堆 => [(3,0,2),(3,1,2),(0,2,2),(0,3,3)]
     结束（k=3 次），返回 12。

#### 示例 B：nums = [1,3,2], k = 2

n = 3
 初始：

-   l=0,r=2: val = 3 - 1 = 2
-   l=1,r=2: val = 3 - 2 = 1
-   l=2,r=2: val = 2 - 2 = 0
     堆 => [(2,0,2),(1,1,2),(0,2,2)]

步骤：

1.  pop (2,0,2): ans=2. push (0,1): val(0,1)=3-1=2
     堆 => [(2,0,1),(1,1,2),(0,2,2)]
2.  pop (2,0,1): ans=4. push (0,0): val(0,0)=1-1=0
     堆 => [(1,1,2),(0,2,2),(0,0,0)]
     结束（k=2），返回 4 —— 与题目示例一致。

Java实现代码：

```java
import java.util.*;

/**
 * Solution: 取所有子数组 val = max - min 的前 k 大之和
 * 思路：对每个左端 l，随着右端 r 增大，val(l,r) 非降。
 * 所以把每个 l 看作一条已经排序（非降）的序列，使用「k-way 最大堆合并」取前 k 大。
 * 区间 max/min 使用稀疏表（Sparse Table）预处理，查询 O(1)。
 */
public class Solution {
    /** 堆中保存的元素（表示某一行 l 的当前候选 r） */
    private static class Node {
        long val; // 当前子数组 [l, r] 的值：max - min，使用 long 存放以避免溢出
        int l;    // 左端
        int r;    // 右端

        Node(long val, int l, int r) {
            this.val = val;
            this.l = l;
            this.r = r;
        }
    }

    /**
     * 主函数：返回能够得到的最大总值（选 k 个不同子数组）
     * @param nums 输入数组
     * @param k    需要选择的子数组数量
     */
    public long maxTotalValue(int[] nums, int k) {
        int n = nums.length;
        if (n == 0 || k == 0) return 0L; // 边界直接返回

        // ------------------ 1. 稀疏表预处理（构造 stMax 和 stMin） ------------------
        // 计算需要的层数 LOG，使得 2^LOG > n（实际使用层数为 LOG）
        int LOG = 1;
        while ((1 << LOG) <= n) LOG++;  // LOG = floor(log2(n)) + 1

        // stMax[j][i] 表示从 i 开始，长度为 2^j 的区间的最大值
        // stMin 同理表示最小值
        int[][] stMax = new int[LOG][n];
        int[][] stMin = new int[LOG][n];

        // level 0：长度为 1 的区间（即元素本身）
        for (int i = 0; i < n; i++) {
            stMax[0][i] = nums[i];
            stMin[0][i] = nums[i];
        }

        // 逐层构建稀疏表：每一层长度是上一层长度的两倍
        for (int j = 1; j < LOG; j++) {
            int len = 1 << j;         // 当前层表示的区间长度 2^j
            int half = 1 << (j - 1);  // 半长度 2^(j-1)
            // i + len - 1 < n 等价于 i + len <= n，保证区间不越界
            for (int i = 0; i + len - 1 < n; i++) {
                // 将两个长度为 2^(j-1) 的子区间合并得到长度为 2^j 的区间
                stMax[j][i] = Math.max(stMax[j - 1][i], stMax[j - 1][i + half]);
                stMin[j][i] = Math.min(stMin[j - 1][i], stMin[j - 1][i + half]);
            }
        }

        // 预处理 lg 数组：lg[x] = floor(log2(x))，用于查询阶段快速得到 j
        int[] lg = new int[n + 1];
        lg[1] = 0;
        for (int i = 2; i <= n; i++) {
            lg[i] = lg[i >> 1] + 1;
        }

        // ------------------ 2. 初始化最大堆（把每一行最大的候选放入堆） ------------------
        // 使用大根堆（Comparator 使得队头为 val 最大的 Node）
        PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> Long.compare(b.val, a.val));

        // 对于每个左端 l，把 r = n-1（该行的最大值）作为初始候选入堆
        for (int l = 0; l < n; l++) {
            long v = rangeValue(l, n - 1, stMax, stMin, lg); // 计算 [l, n-1] 的 val（max-min）
            pq.offer(new Node(v, l, n - 1));
        }

        // ------------------ 3. 取前 k 大（每次取堆顶并把同一行的下一个候选入堆） ------------------
        long ans = 0L;
        for (int t = 0; t < k; t++) {
            if (pq.isEmpty()) break; // 如果堆空（保险），提前结束
            Node cur = pq.poll();    // 取当前最大
            ans += cur.val;          // 累加到答案

            // 同一行把下一个候选（右端左移一位 r-1）放入堆（前提 r > l）
            // 这样保证每个 (l,r) 只会被取出一次（不会选同一个区间两次）
            if (cur.r > cur.l) {
                long nextVal = rangeValue(cur.l, cur.r - 1, stMax, stMin, lg);
                pq.offer(new Node(nextVal, cur.l, cur.r - 1));
            }
        }

        return ans;
    }

    /**
     * 使用稀疏表查询区间 [l, r] 的 max-min 值（O(1)）
     * @param l    左端
     * @param r    右端
     * @param stMax 稀疏表（最大值）
     * @param stMin 稀疏表（最小值）
     * @param lg   预计算的对数表
     * @return     max(nums[l..r]) - min(nums[l..r])
     */
    private static long rangeValue(int l, int r, int[][] stMax, int[][] stMin, int[] lg) {
        int len = r - l + 1;         // 区间长度
        int j = lg[len];             // j = floor(log2(len))
        int leftMax = stMax[j][l];   // 左块的最大
        int rightMax = stMax[j][r - (1 << j) + 1]; // 右块的最大（起点为 r-2^j+1）
        int maxi = Math.max(leftMax, rightMax);

        int leftMin = stMin[j][l];   // 左块的最小
        int rightMin = stMin[j][r - (1 << j) + 1]; // 右块的最小
        int mini = Math.min(leftMin, rightMin);

        return (long) maxi - (long) mini; // 返回差值（使用 long 避免中间整型溢出）
    }
}
```