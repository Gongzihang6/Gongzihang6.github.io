# 第 467 场周赛

## Q1. 完成一个任务的最早时间

简单 3 分

给你一个二维整数数组 `tasks`，其中 `tasks[i] = [si, ti]`。数组中的每个 `[si, ti]` 表示一个任务，该任务的开始时间为 `si`，完成该任务需要 `ti` 个时间单位。返回至少完成一个任务的最早时间。

 示例 1：

```
输入： tasks = [[1,6],[2,3]]

输出： 5

解释：第一个任务从时间 t = 1 开始，并在 1 + 6 = 7 时完成。第二个任务在时间 t = 2 开始，并在 2 + 3 = 5 时完成。因此，最早完成的任务在时间 5。
```

示例 2：

```
输入： tasks = [[100,100],[100,100],[100,100]]

输出： 200

解释：三个任务都在时间 100 + 100 = 200 时完成。
```

提示：

-   1 <= tasks.length <= 100
-   tasks [i] = [si, ti]
-   1 <= si, ti <= 100©leetcode

### 我的解法：

思路很简单，任务列表 `tasks` 中的每一个任务 `[si, ti]` 给出了该任务的开始执行时间和所需耗时，要求返回至少完成一个任务的最早时间，要尽快的先完成一个任务，就应该挑开始时间尽可能早，耗时尽可能短的任务优先完成，所以直接遍历任务列表 `tasks`，记录当前任务的完成时间 `（si+ti）`，并逐步用更短的完成时间来替换 `result`，即可得到最早完成时间

```java
class Solution {
    public int earliestTime(int[][] tasks) {
        int result = Integer.MAX_VALUE;  // 记录结果，完成一个任务的最早时间
        for(int i=0;i<tasks.length;i++){
            if(tasks[i][0]+tasks[i][1]<result){
                result = tasks[i][0]+tasks[i][1];
            }
        }
        return result;
    }
}
```

## Q2. 至多 K 个不同元素的最大和

简单 3 分
给你一个 正整数 数组 nums 和一个整数 k。从 nums 中选择最多 k 个元素，使它们的和最大化。但是，所选的数字必须 互不相同 。返回一个包含所选数字的数组，数组中的元素按 严格递减 顺序排序。

示例 1：

```
输入： nums = [84,93,100,77,90], k = 3

输出： [100,93,90]

解释：最大和为 283，可以通过选择 93、100 和 90 实现。将它们按严格递减顺序排列，得到 [100, 93, 90]。
```

示例 2：

```
输入： nums = [84,93,100,77,93], k = 3

输出： [100,93,84]

解释：最大和为 277，可以通过选择 84、93 和 100 实现。将它们按严格递减顺序排列，得到 [100, 93, 84]。不能选择 93、100 和另一个 93，因为所选数字必须互不相同。
```

示例 3：

```
输入： nums = [1,1,1,2,2,2], k = 6

输出： [2,1]

解释：最大和为 3，可以通过选择 1 和 2 实现。将它们按严格递减顺序排列，得到 [2, 1]。
```

提示：

-   1 <= nums.length <= 100
-   1 <= nums [i] <= 109
-   1 <= k <= nums.length©leetcode



### 我的解法：

题目要求从nums中选择最多k个元素，并且使得它们的和最大化，但是所选的k个数字必须互不相同。所以只要选择nums中前k大元素即可，但是如果这前k大数字中有重复，就不符合题目要求了，所以我想到只需要将nums按照从大到小排序，逐步选择最大元素，然后使用一个计数器count记录选择的数字个数，

-   如果当前数字和后一个数字相等，则直接跳过；
-   如果不相等，则累加到结果result中，记录总和。

达到k个后就停止选择。

Java实现代码如下：

```java
class Solution {
    public int[] maxKDistinct(int[] nums, int k) {
        Arrays.sort(nums);
        List<Integer> result = new ArrayList<>();
        int count = 1;
        result.add(nums[nums.length-1]);
        if(nums.length==1){
            return result.stream().mapToInt(Integer::intValue).toArray();
        }
        for(int i=nums.length-2;i>=0;i--){
            if(count==k){
                break;
            }
            if(nums[i]==nums[i+1]){
                continue;
            }
            else{
                result.add(nums[i]);
                count++;
            }
        }
        return result.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

**不足之处：**

1.  
2.  **代码略显繁琐**：你需要手动管理计数器count，处理i和i+1的比较来去重，以及处理只有一个元素的边界情况。这使得代码的逻辑分支变多，可读性稍差。
3.  **可读性有待提升**：代码的核心是“去重”和“取最大”，但这个意图被循环、if-else判断和手动计数等过程化的代码所掩盖。使用更合适的数据结构可以直接地表达这个意uto。
4.  **对Java特性的利用不足**：Java的集合框架（如Set）和Stream API提供了更简洁、更具表现力的方式来处理这类涉及去重、排序和筛选的问题。

------

### 优化方案

这里提供一个更优的解决方案，主要思路是利用 Set 的特性来自动去重，然后进行排序和截取。这种方法代码更简洁，逻辑更清晰。

#### 详细解题思路：

1.  **去重**：利用 HashSet 的特性，将 nums 数组中的所有元素添加到一个 Set 中。Set 会自动处理掉所有重复的元素，只保留唯一值。
2.  **排序**：将 Set 中的唯一元素转换成一个 List，然后对这个 List 进行降序排序。这样，最大的元素就在列表的最前面。
3.  **截取**：根据题目要求，我们最多需要 k 个元素。因此，我们从排好序的列表中取出前 k 个元素。需要注意的是，如果唯一元素的总数少于 k，我们就取所有的唯一元素。
4.  **转换结果**：将最终选出的元素列表转换为 int[] 数组作为最终结果返回。

这个思路可以非常优雅地用Java的Stream API一行代码实现，使其更加简洁高效。

#### Java 实现代码

下面是利用上述思路的两种实现方式。

**方案一：使用集合框架（Set 和 List）**

这种方法分步清晰，易于理解。

```java
import java.util.*;

class Solution {
    public int[] maxKDistinct(int[] nums, int k) {
        // 1. 使用 TreeSet 自动去重并按降序排序
        // TreeSet 内部使用红黑树，添加元素时会自动排序。
        // 我们提供一个反向比较器，使其直接按降序排列。
        SortedSet<Integer> uniqueSortedNums = new TreeSet<>(Comparator.reverseOrder());
        for (int num : nums) {
            uniqueSortedNums.add(num);
        }

        // 2. 从排序后的 Set 中取出最多 k 个元素
        List<Integer> resultList = new ArrayList<>();
        int count = 0;
        for (Integer num : uniqueSortedNums) {
            if (count < k) {
                resultList.add(num);
                count++;
            } else {
                break;
            }
        }

        // 3. 将 List 转换为 int[] 数组并返回
        return resultList.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

**方案二：使用 Java Stream API (更简洁)**

这是目前解决此类问题的最地道、最简洁的Java写法。它将多个操作链接在一起，可读性非常高。

```java
import java.util.Arrays;
import java.util.Comparator;

class Solution {
    public int[] maxKDistinct(int[] nums, int k) {
        return Arrays.stream(nums)  // 1. 将数组转换为流
                .distinct()     // 2. 去除流中的重复元素
                .boxed()        // 3. 将 int 流转换为 Integer 流，以便使用自定义比较器
                .sorted(Comparator.reverseOrder()) // 4. 对流中的元素进行降序排序
                .limit(k)       // 5. 截取流的前 k 个元素
                .mapToInt(Integer::intValue) // 6. 将 Integer 流转换回 int 流
                .toArray();    // 7. 将流转换为数组并返回
    }
}
```



## Q3. 含上限元素的子序列和

中等 5 分

给你一个大小为 `n` 的整数数组 `nums` 和一个正整数 `k`。通过将`nums`中的每个元素 `nums[i]` 替换为 `min(nums[i], x)`，可以得到一个由值 x 限制（capped）的数组。

对于从 1 到 `n` 的每个整数 x，**确定是否可以**从由 x 限制的数组中选择一个 子序列，使所选元素的和 恰好 为 k。

返回一个下标从 0 开始的布尔数组 `answer`，其大小为 n，其中 `answer[i]` 为 true 表示当 `x = i + 1` 时可以选出满足要求的子序列；否则为 false。

子序列 是一个从数组中通过删除一些或不删除任何元素（且不改变剩余元素顺序）派生出来的 非空 数组。


示例 1：

```
输入： nums = [4,3,2,4], k = 5

输出： [false,false,true,true]

解释：

对于 x = 1，限制后的数组为 [1, 1, 1, 1]。可能的和为 1, 2, 3, 4，因此无法选出和为 5 的子序列。
对于 x = 2，限制后的数组为 [2, 2, 2, 2]。可能的和为 2, 4, 6, 8，因此无法选出和为 5 的子序列。
对于 x = 3，限制后的数组为 [3, 3, 2, 3]。可以选择子序列 [2, 3]，其和为 5，能选出满足要求的子序列。
对于 x = 4，限制后的数组为 [4, 3, 2, 4]。可以选择子序列 [3, 2]，其和为 5，能选出满足要求的子序列。
```

示例 2：

```
输入： nums = [1,2,3,4,5], k = 3

输出： [true,true,true,true,true]

解释：

对于每个值 x，总是可以从限制后的数组中选择一个子序列，其和正好为 3。
```

提示：

-   1 <= n == `nums.length` <= 4000
-   1 <= `nums[i]` <= n
-   1 <= k <= 4000

### 我的思路

弄混了子数组求和与子序列求和

获取原始数组nums的长度n，遍历从1到n的每一个整数x，遍历原始数组`nums`来获取由x限制的临时数组`nums_temp`，在获取nums_temp的每一个元素的过程中，累加这些元素的和，如果累加和小于k，则继续累加元素和，如果大于k，则删除掉最前面的元素，直到累加和等于k为止。这本质上是在找满足累加和等于k的子数组，而不是子序列。

```java
class Solution {
    public boolean[] subsequenceSumAfterCapping(int[] nums, int k) {
        int n = nums.length;
        int [] nums_temp = new int [n];
        boolean [] result = new boolean [n];
        for(int i=1;i<=n;i++){
            int sum = 0;
            int p = 0;
            for(int j=0;j<n;j++){
                nums_temp[j] = Math.min(i, nums[j]);
                if(sum < k){
                    sum += nums_temp[j];
                }
                else if(sum > k){
                    sum -= nums_temp[p];
                    p = j-1;
                    j--;
                }
                else{
                    result[i-1] = true;
                }
            }
        }
        return result;
    }
}
```

**解答错误298 / 794 个通过的测试用例**

输入

nums =[1] k =1

输出 [false]

预期结果 [true]

## Q4. 稳定子序列的数量

困难 6 分
给你一个整数数组 nums。如果一个 子序列 中 不存在连续三个 元素奇偶性相同（仅考虑该子序列内），则称该子序列为稳定子序列 。请返回所有稳定子序列的数量。

由于结果可能非常大，请将答案对 10^9 + 7 取余数后返回。

子序列 是一个从数组中通过删除某些元素（或不删除任何元素），并保持剩余元素相对顺序不变的 非空 数组。

示例 1：

```
输入： nums = [1,3,5]

输出： 6

解释：

稳定子序列为：[1], [3], [5], [1, 3], [1, 5], 和 [3, 5]。
子序列 [1, 3, 5] 不稳定，因为它包含三个连续的奇数。因此答案是 6。
```

示例 2：

```
输入： nums = [2,3,4,2]

输出： 14

解释：

唯一一个不稳定子序列是 [2, 4, 2]，因为它包含三个连续的偶数。
所有其他子序列都是稳定子序列。因此答案是 14。
```


提示：

-   1 <= nums.length <= 105
-   1 <= nums [i] <= 105©leetcode