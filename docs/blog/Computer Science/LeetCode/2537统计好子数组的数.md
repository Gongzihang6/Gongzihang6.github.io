# [2537. 统计好子数组的数目](https://leetcode.cn/problems/count-the-number-of-good-subarrays/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回 `nums` 中 **好** 子数组的数目。

一个子数组 `arr` 如果有 **至少** `k` 对下标 `(i, j)` 满足 `i < j` 且 `arr[i] == arr[j]` ，那么称它是一个 **好** 子数组。

**子数组** 是原数组中一段连续 **非空** 的元素序列。

 

**示例 1：**

```
输入：nums = [1,1,1,1,1], k = 10
输出：1
解释：唯一的好子数组是这个数组本身。
```

**示例 2：**

```
输入：nums = [3,1,4,3,2,2,4], k = 2
输出：4
解释：总共有 4 个不同的好子数组：
- [3,1,4,3,2,2] 有 2 对。
- [3,1,4,3,2,2,4] 有 3 对。
- [1,4,3,2,2,4] 有 2 对。
- [4,3,2,2,4] 有 2 对。
```

**提示：**

- `1 <= nums.length <= 10^5`
- `1 <= nums[i], k <= 10^9`



### 方法思路
这道题目要求统计数组中满足条件的“好”子数组的数目。好子数组的定义是子数组中至少存在 k 对相同的元素。直接暴力枚举所有可能的子数组显然不可行，因为时间复杂度会达到 $O(n^2)$，对于 $n=1e5$ 来说，这样的复杂度是无法接受的。

我们可以使用滑动窗口的方法来高效地统计满足条件的子数组数目。具体思路如下：

1. **滑动窗口维护**：使用双指针维护一个窗口 [left, right]，使得窗口内的子数组满足其中的相同元素对数至少为 $k$。我们需要动态调整窗口的左右边界，以确保高效统计。

2. **哈希表记录频率**：使用哈希表（或字典）来记录当前窗口中每个元素的出现次数。这样可以快速计算新增或减少一个元素时对总对数的影响。

3. **对数计算**：每当窗口右边界向右移动，包含一个新元素时，==该元素在窗口中已存在的次数即为新增的对数==。例如，如果一个元素已经出现了 $m$ 次，那么新增的相同元素会新增 $m$ 对。

4. **滑动窗口调整**：当窗口内的总对数不少于 $k$ 时，尝试移动左边界，以找到所有以 right 结尾的满足条件的最小子数组。每移动一次左边界，就可以得到 left 左边所有位置到 right 的子数组都满足条件，从而累加这些子数组的数目。

### 解决代码
```cpp
class Solution {
public:
    long long countGood(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        long long res = 0;
        int left = 0;
        long long current_pairs = 0;
        
        for (int right = 0; right < nums.size(); ++right) {
            // 增加右指针对应的元素，并更新当前的对数
            // 每增加一个nums[right]，它会和之前所有的nums[right]形成新的对
            current_pairs += freq[nums[right]];
            freq[nums[right]]++;
            
            // 当当前对数 >=k 时，移动左指针，直到对数小于k
            while (current_pairs >= k) {
                // 左指针移动时，需要减少nums[left]的计数，并更新对数
                // 减少一个nums[left]，之前它和所有其他nums[left]形成的对需要减去
                freq[nums[left]]--;
                current_pairs -= freq[nums[left]];
                left++;
            }
            
            // 每次左指针移动前的left值表示以right结尾的满足条件的最小子数组的起始位置
            // 所有left左边的起始位置到right的子数组都满足条件
            res += left;
        }
        
        return res;
    }
};
```

### 代码解释
1. **初始化**：使用哈希表 `freq` 来记录当前窗口中各元素的出现次数，`res` 用于累计结果，`left` 作为窗口的左指针，`current_pairs` 记录当前窗口中的相同元素对数。
2. **滑动窗口扩展**：遍历数组，右指针 `right` 每次向右移动一位。新增元素 `nums[right]` 时，它在窗口中已存在的次数即为新增的对数，更新 `current_pairs` 和 `freq`。
3. **滑动窗口收缩**：当 `current_pairs` 不小于 `k` 时，移动左指针 `left`，并减少 `nums[left]` 的计数及其对 `current_pairs` 的贡献，直到 `current_pairs` 小于 `k`。
4. **结果统计**：每次右指针移动后，`left` 的位置即为以 `right` 结尾的满足条件的最小子数组的起始位置。`left` 左边的所有起始位置到 `right` 的子数组都满足条件，因此将 `left` 累加到结果 `res` 中。

这种方法确保了每个元素最多被处理两次（左右指针各一次），时间复杂度为 **$O(n)$**，适用于大规模数据。

