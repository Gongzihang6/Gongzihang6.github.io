# [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

```
输入：matrix = [["0","1"],["1","0"]]
输出：1
```

**示例 3：**

```
输入：matrix = [["0"]]
输出：0
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 300`
- `matrix[i][j]` 为 `'0'` 或 `'1'`

### **思路：动态规划**

1. **动态规划状态定义**：
   - `dp[i][j]` 表示以 `matrix[i-1][j-1]` 为右下角的最大正方形的边长
   - 初始化 `dp` 数组比原矩阵大一圈，便于处理边界情况
2. **状态转移方程**：
   - 如果 `matrix[i-1][j-1]` 是 '1'，则
     `dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])`
   - 这意味着正方形的大小取决于左上、上方、左侧的最小正方形边长
   - 如果某个位置是 '0'，则 `dp[i][j]` 保持为 0
3. **最大面积计算**：
   - 记录最大边长 `max_square`
   - 最终返回 `max_square * max_square`

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        // 处理边界情况
        if (matrix.empty() || matrix[0].empty()) {
            return 0;
        }
        
        int m = matrix.size();
        int n = matrix[0].size();
        
        // 创建动态规划数组，比原矩阵大一圈
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        
        // 记录最大边长
        int max_square = 0;
        
        // 遍历每一个位置
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 只处理值为 '1' 的位置
                if (matrix[i-1][j-1] == '1') {
                    // `dp[i][j]` 表示以 `matrix[i-1][j-1]` 为右下角的最大正方形的边长
                    // 状态转移：取左上、上方、左侧的最小值并加1
                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]});
                    
                    // 更新最大边长
                    max_square = max(max_square, dp[i][j]);
                }
            }
        }
        
        // 返回最大面积
        return max_square * max_square;
    }
};
```





















让我通过一个具体的例子来详细解释这个状态转移方程。

### 直观解释

假设我们有这样一个矩阵：

```
1 1 1
1 1 1
1 1 0
```

我们来看每个位置的 `dp` 值：

1. 首先，对于第一行和第一列，如果是 '1'，`dp` 值就是 1。
2. 对于中间位置 (1,1)，我们计算 `dp[2][2]`：
   - 左上方 `dp[1][1]` = 1
   - 上方 `dp[1][2]` = 1
   - 左侧 `dp[2][1]` = 1
   - `min(1,1,1) = 1`
   - 所以 `dp[2][2] = 1 + 1 = 2`
3. 同理，对于 (1,2) 位置：
   - 左上方 `dp[1][1]` = 1
   - 上方 `dp[1][2]` = 1
   - 左侧 `dp[2][1]` = 1
   - `min(1,1,1) = 1`
   - 所以 `dp[2][3] = 1 + 1 = 2`

### 几何直观解释

想象这个状态转移方程是在判断：**以当前位置为右下角，我们能构成多大的正方形？**

```
   左上   上方
    ↓     ↓
   [1] [1] [1]
   [1] [?] [ ]
   [1] [ ] [ ]
        ←   ←
      左侧
```

- 如果左上、上方、左侧已经形成了边长为 k 的正方形
- 那么当前位置能形成的最大正方形边长就是 k+1
- 关键在于：这三个方向的最小值决定了我们能扩展的程度

### 具体示例

考虑以下矩阵：

```
1 1 1
1 1 1
1 1 0
```

`dp` 数组的演变：

```
初始：
0 0 0 0
0 1 1 1
0 1 2 2
0 1 2 0

最终：
0 0 0 0
0 1 1 1
0 1 2 2
0 1 2 0
```

### 为什么取最小值？

举个例子说明：

```
1 1 1
1 0 1  // 中间是 0
1 1 1
```

在 (1,1) 位置（从 0 开始计数），周围情况是：

- 左上：1
- 上方：1
- 左侧：1

但是因为左上方有 0，所以能形成的最大正方形只能是 1x1。

### 代码演示

```cpp
// 状态转移的本质
if (matrix[i-1][j-1] == '1') {
    // 取三个方向的最小值，表示扩展的极限
    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]});
}
```

### 核心思想

1. 正方形需要"四周都是1"
2. 扩展正方形的极限取决于三个方向的最小值
3. 每个位置都尝试以自己为右下角构建最大正方形

### 形象比喻

想象你在玩一个方块拼图游戏：

- 你总是希望拼出最大的正方形
- 但受限于周围已经拼好的方块
- 能拼的大小取决于周围最小的那个方块组合

这个状态转移方程就是在模拟这个拼图过程，找出每个位置能拼出的最大正方形。