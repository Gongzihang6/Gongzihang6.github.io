# [2140. 解决智力问题](https://leetcode.cn/problems/solving-questions-with-brainpower/)

给你一个下标从 **0** 开始的二维整数数组 `questions` ，其中 `questions[i] = [pointsi, brainpoweri]` 。

这个数组表示一场考试里的一系列题目，你需要 **按顺序** （也就是从问题 `0` 开始依次解决），针对每个问题选择 **解决** 或者 **跳过** 操作。解决问题 `i` 将让你 **获得** `pointsi` 的分数，但是你将 **无法** 解决接下来的 `brainpoweri` 个问题（即只能跳过接下来的 `brainpoweri` 个问题）。如果你跳过问题 `i` ，你可以对下一个问题决定使用哪种操作。

- 比方说，给你

  ```
  questions = [[3, 2], [4, 3], [4, 4], [2, 5]]
  ```

  - 如果问题 `0` 被解决了， 那么你可以获得 `3` 分，但你不能解决问题 `1` 和 `2` 。
  - 如果你跳过问题 `0` ，且解决问题 `1` ，你将获得 `4` 分但是不能解决问题 `2` 和 `3` 。

请你返回这场考试里你能获得的 **最高** 分数。

**示例 1：**

```
输入：questions = [[3,2],[4,3],[4,4],[2,5]]
输出：5
解释：解决问题 0 和 3 得到最高分。
- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。
- 不能解决问题 1 和 2
- 解决问题 3 ：获得 2 分
总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。
```

**示例 2：**

```
输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
输出：7
解释：解决问题 1 和 4 得到最高分。
- 跳过问题 0
- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。
- 不能解决问题 2 和 3
- 解决问题 4 ：获得 5 分
总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。
```

**提示：**

- `1 <= questions.length <= 105`
- `questions[i].length == 2`
- `1 <= pointsi, brainpoweri <= 105`

**思路：动态规划**

这道题比较特殊的地方在于，动态规划数组 dp 是从后往前遍历的，这里定义 dp [i] 表示的是从第 i 道题开始，一直到最后一道题的范围内能够获得的最大分数，根据状态转移关系，如果选择做当前这道题，则从第 i 道题开始能够获得的最大分数应该是当前这道题的分数加上按照规则而应该跳过 brainpower_i 道题后，从后面那道题开始往后能够获得的最大分数之和；如果选择不做这道题，则从第 i 道题开始能够获得的最大分数就等于从第 i+1 道题开始能够获得的最大分数，因为第 i 道题不做。所以最终从第 i 道题开始能够获得的最大分数应该取上面两种情况的较大者。

```cpp
class Solution {
public:
    long long mostPoints(vector<vector<int>>& questions) {
        int n = questions.size();
        vector<long long> dp(n + 1, 0);  // 定义 dp[i] 为从第 i 个问题开始（即考虑问题 i 到问题 n-1）时，能够获得的最大分数

        // 从后往前遍历  
        for (int i = n - 1; i >= 0; i--) {
            // 解决当前问题的分数  
            long long points = questions[i][0];

            // 计算下一个可以解决的问题的索引  
            int nextIndex = i + questions[i][1] + 1;

            // 状态转移：选择解决当前问题或跳过 
            // 因为是从后往前遍历，所以解决问题i能够获得的最高分数就是问题i的分数，加上跳过brainpower个问题后，截至到该索引的前面所有问题能够获得的最高分数
            dp[i] = max(
                points + (nextIndex < n ? dp[nextIndex] : 0),
                // 跳过问题i能够获得的最高分数
                dp[i + 1]
            );
        }

        return dp[0];	  // 最终返回dp[0]，也就是从第0个问题开始，一直到最后一个问题（n-1）能够获得的最大分数
    }
};
```

**动态规划的思路**

动态规划（Dynamic Programming, DP）是解决这类最优化问题的有效方法。我们需要找到一个状态表示和状态转移方程。

**状态表示**

> 定义 `dp[i]` 为从第 `i` 个问题开始（即考虑问题 `i` 到问题 `n-1`）时，能够获得的最大分数。这里 `n` 是问题的总数。

**状态转移**

对于第 `i` 个问题，我们有两个选择：

1. **解决当前问题**：
   - 获得 `points[i]` 的分数。
   - 然后必须跳过接下来的 `brainpower[i]` 个问题，所以下一个可以解决的问题是 `i + brainpower[i] + 1`。
   - 因此，如果选择解决当前问题，总分数为 `points[i] + dp[i + brainpower[i] + 1]`（如果 `i + brainpower[i] + 1` 在范围内）。

2. **跳过当前问题**：
   - 不获得分数，直接考虑下一个问题 `i + 1`。
   - 因此，总分数为 `dp[i + 1]`。

我们需要在这两个选择中取最大值：

```cpp
// 状态转移：选择解决当前问题或跳过 
// 因为是从后往前遍历，所以解决问题i能够获得的最高分数就是问题i的分数，加上跳过brainpower个问题后，截至到该索引的前面所有问题能够获得的最高分数
dp[i] = max(
    points + (nextIndex < n ? dp[nextIndex] : 0),
    // 跳过问题i能够获得的最高分数
    dp[i + 1]
);
```

**示例分析**

让我们用第一个示例来验证：

**示例 1**：
```python
questions = [[3,2],[4,3],[4,4],[2,5]]
```

- `n = 4`
- `dp` 初始化为 `[0, 0, 0, 0, 0]`

**从后往前计算**：

1. `i = 3`:
   - `points = 2`, `brainpower = 5`
   - `nextIndex = 3 + 5 + 1 = 9` (>= 4, 所以后面分数为 0)
   - `dp[3] = max(2 + 0, dp[4]) = max(2, 0) = 2`

   `dp = [0, 0, 0, 2, 0]`

2. `i = 2`:
   - `points = 4`, `brainpower = 4`
   - `nextIndex = 2 + 4 + 1 = 7` (>= 4, 所以后面分数为 0)
   - `dp[2] = max(4 + 0, dp[3]) = max(4, 2) = 4`

   `dp = [0, 0, 4, 2, 0]`

3. `i = 1`:
   - `points = 4`, `brainpower = 3`
   - `nextIndex = 1 + 3 + 1 = 5` (>= 4, 所以后面分数为 0)
   - `dp[1] = max(4 + 0, dp[2]) = max(4, 4) = 4`

   `dp = [0, 4, 4, 2, 0]`

4. `i = 0`:
   - `points = 3`, `brainpower = 2`
   - `nextIndex = 0 + 2 + 1 = 3` (< 4, `dp[3] = 2`)
   - `dp[0] = max(3 + 2, dp[1]) = max(5, 4) = 5`

   `dp = [5, 4, 4, 2, 0]`

最终 `dp[0] = 5`，与示例输出一致。

### **为什么从后往前遍历？**

因为 `dp[i]` 依赖于 `dp[i + brainpower[i] + 1]` 和 `dp[i + 1]`，即依赖于后面的 `dp` 值。如果从前往后遍历，后面的 `dp` 值还没有计算出来，无法使用。而从后往前可以确保在计算 `dp[i]` 时，后面的 `dp` 值已经计算好了。

### 时间复杂度

- 遍历所有问题一次：$O(n)$
- 每个问题的处理是常数时间：$O(1)$
- 总时间复杂度：$O(n)$

### 空间复杂度

- `dp` 数组：$O(n)$

### 总结

这道题的关键在于：

1. 定义 `dp[i]` 为从第 `i` 个问题开始能够获得的最大分数。
2. 从后往前遍历，利用已经计算的后面的 `dp` 值来更新当前的 `dp[i]`。
3. 对于每个问题，选择解决或跳过，取最大值。

这种方法确保了我们在最优子结构的基础上，通过动态规划高效地计算出最大分数。



