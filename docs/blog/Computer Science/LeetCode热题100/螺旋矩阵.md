# [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。



**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```txt
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```txt
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```



**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`

## 我的思路

**仅能通过少数用例。**因为我的第一直觉是按层模拟这个问题，将矩阵像剥洋葱一样一层一层剥开，但是在处理**边界条件**和**剩余中心部分**时存在严重的逻辑漏洞，导致无法通过大部分测试用例。

```c++
/**
1、把顺时针螺旋遍历，看成一圈一圈不断向内、向中心的遍历过程，需要遍历的圈数取决于行、列中较短的
    一个，圈数=min{行，列}//2 + 1；
2、最外层遍历圈数，然后内层执行4个独立for循环，遍历向右、向下、向左、向上四个方向，遍历完就是一圈，
    然后开始新的一圈，知道遍历完所有圈
*/

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        int q = min(m,n)/2;
        vector<int> result;
        for(int k=0;k<q;k++){
            for(int j=k;j<n-2*k;j++){
                result.push_back(matrix[k][j]);
            }
            for(int i=k+1;i<m-2*k;i++){
                result.push_back(matrix[i][n-2*k-1]);
            }
            for(int j=n-2*k-2;j>=k;j--){
                result.push_back(matrix[m-2*k-1][j]);
            }
            for(int i=m-2*k-2;i>k;i--){
                result.push_back(matrix[i][k]);
            }
        }
        if(q%2==1){
            for(int i=q;i<=n-q-1;i++)
            result.push_back(matrix[q][i]);
        }
        return result;
    }
};
```

### 1. 核心逻辑漏洞分析

#### A. 剩余部分的判断条件错误

使用了 `if(q % 2 == 1)` 来判断是否需要处理中心剩余部分。

- **错误点**：`q = min(m, n) / 2` 代表的是完整的“圈数”。`q` 的奇偶性与矩阵中心是否有剩余元素 **毫无关系**。
- **反例**：
  - `5 x 5` 矩阵：`min(5,5)=5`, `q=2`。`q` 是偶数，你的代码会跳过 `if`，导致中心点 `matrix[2][2]` 丢失。
  - `3 x 3` 矩阵：`min(3,3)=3`, `q=1`。`q` 是奇数，代码会执行 `if`，结果正确（巧合）。
- **正确逻辑**：应该看 `min(m, n) % 2` 是否不为 0。

#### B. 无法处理“非方阵”的剩余部分（最严重的问题）

你的补救代码（`if` 块内）假设剩余的一定是一 **行**：

C++

```c++
for(int i=q; i<=n-q-1; i++) result.push_back(matrix[q][i]);
```

- **错误点**：如果剩余的是一 **列** 呢？
- **反例**：
  - `3 x 4` 矩阵：`m=3, n=4`，`q=1`。剩下一行 `[1, 2]`（假设索引），没问题。
  - `4 x 3` 矩阵：`m=4, n=3`，`q=1`。剩下一列（竖着的中心）。你的代码只会尝试横向遍历，导致逻辑错误或漏掉数据。

#### C. “扁长”矩阵直接挂掉

- **错误点**：对于 `1 x 5` 或 `5 x 1` 这种单行单列矩阵。
  - `min(1, 5) = 1`，`q = 1 / 2 = 0`。
  - 循环 `k < 0` 不执行。
  - `q % 2 == 0`，补救代码不执行。
  - **输出为空** `[]`，预期应该是 `[1, 2, 3, 4, 5]`。

#### D. 循环边界计算复杂且易错

- 在 `for(int j=k; j<n-2*k; j++)` 中，你试图用 `n-2*k` 作为边界。
  - 当 `k` 增大时，起始点 `j=k` 也在增大。
  - 正确的逻辑应该是：长度是 `n - 2*k`，但终止索引应该是 `Start + Length`，即 `k + (n - 2*k) = n - k`。
  - 你的写法会导致内层圈遍历的元素比预期的少。

## 正确思路

与其去计算复杂的下标公式和圈数，不如直接定义四个边界：`top`（上）, `bottom`（下）, `left`（左）, `right`（右）。 每次遍历一条边后，将对应的边界向内收缩，并判断是否越界。这种方法逻辑最清晰，不易出错。

```c++
/*
思路：设定四个边界 limit (上、下、左、右)
1. 从左到右遍历，上边界下移 (top++)
2. 从上到下遍历，右边界左移 (right--)
3. 从右到左遍历，下边界上移 (bottom--)
4. 从下到上遍历，左边界右移 (left++)
每次移动边界后，立即检查是否 top > bottom 或 left > right，如果是则结束。
*/

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        if (matrix.empty()) return result;

        // 定义四个边界
        int top = 0;
        int bottom = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;

        while (true) {
            // 1. 从左向右 (Left -> Right)
            for (int i = left; i <= right; ++i) {
                result.push_back(matrix[top][i]);
            }
            if (++top > bottom) break; // 上边界下移，并判断是否越界

            // 2. 从上向下 (Top -> Bottom)
            for (int i = top; i <= bottom; ++i) {
                result.push_back(matrix[i][right]);
            }
            if (--right < left) break; // 右边界左移

            // 3. 从右向左 (Right -> Left)
            for (int i = right; i >= left; --i) {
                result.push_back(matrix[bottom][i]);
            }
            if (--bottom < top) break; // 下边界上移

            // 4. 从下向上 (Bottom -> Top)
            for (int i = bottom; i >= top; --i) {
                result.push_back(matrix[i][left]);
            }
            if (++left > right) break; // 左边界右移
        }

        return result;
    }
};
```

### 3. 为什么这个方法更好？

1. **处理剩余中心**：不需要单独写 `if` 判断中心是横条还是竖条，`while` 循环内的边界检查（`break`）会自动处理所有情况。
2. **处理单行/单列**：如果只有一行，执行完“从左向右”后，`top` 增加，`top > bottom` 成立，直接退出，完全正确。
3. **可读性**：逻辑符合人类直觉（转圈圈），不需要计算 `n - 2*k` 这种复杂的数学公式。
