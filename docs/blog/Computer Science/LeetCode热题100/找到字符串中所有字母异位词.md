# [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

>   异位词：字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**提示:**

-   `1 <= s.length, p.length <= 3 * 10^4`
-   `s` 和 `p` 仅包含小写字母

## 我的思路

用 HashMap 记录下字符串 `p` 中的所有字符以及对应出现的次数，也就是 `Map<Character, Integer> map1 = new HashMap<>();`，键为字符串 `p` 中的字符，值为该字符在字符串 `p` 中出现的次数；同样的，使用另一个新的 HashMap，也就是 `Map<Character, Integer> map2 = new HashMap<>();` 来记录滑动窗口下字符串 `s` 中长度为 `n` 的子串的字符以及字符出现次数，如果滑动窗口下的 `map2` 和字符串 `p` 的 `map1` 两个 HashMap 完全相等，则说明当前 `s` 的子串是字符串 `p` 的字母异位词。

时间复杂度：$O(m\cdot n)$，其中 `m` 为字符串 `s` 的长度，`n` 为字符串 `p` 的长度

但是超市，因为 m 和 n 最大为 10^4，mn 就是 10^8，无法接受。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int m = s.length();
        int n = p.length();
        Map<Character, Integer> map1 = new HashMap<>();
        for(int i=0;i<n;i++){
            if(map1.get(p.charAt(i)) == null){
                map1.put(p.charAt(i),1);
            }
            else{
                map1.put(p.charAt(i), map1.get(p.charAt(i))+1);
            }
        }
        List<Integer> re = new ArrayList<>();
        for(int i = 0;i<m-n+1;i++){
            Map<Character, Integer> map2 = new HashMap<>();
            for(int j=i;j<i+n;j++){
                if(map2.get(s.charAt(j)) == null){
                    map2.put(s.charAt(j),1);
                }
                else{
                    map2.put(s.charAt(j), map2.get(s.charAt(j))+1);
                }
            }
            if(map1.equals(map2)){
                re.add(i);
            }
        }
        return re;
        
    }
}
```

## 优化思路

使用 **滑动窗口** 和 **数组哈希** 来优化时间复杂度。具体步骤如下：

1.  **数组哈希**：用两个长度为 26 的数组 `countP` 和 `countS` 分别记录 `p` 和当前窗口的字符频率。
2.  **滑动窗口**：在 `s` 上滑动窗口，每次移动窗口时，更新 `countS` 数组，并比较 `countS` 和 `countP` 是否相等。
3.  **时间复杂度**：优化后的时间复杂度为 `O(m)`，其中 `m` 是 `s` 的长度。

使用数组哈希 `countP` 来记录字符串 `p` 中的字符和该字符出现的次数，由于题目中说明 `s` 和 `p` 字符串中仅包含小写字母，所以可以用一个长度为 26 的数组来记录字符串中每个字符出现的频率，从索引 0 到索引 25，依次代表小写字母 a 到 z，对应的数组值就是该字母的出现次数；以同样的方式用 `countS` 数组来记录字符串 `s` 中长度为 n 的滑动窗口内字符的出现次数，不过这里 **不采用嵌套循环** 的方式来记录，而是<span style="color:#d59bf6;">在遍历字符串 `s` 的过程中，当遍历的长度超过字符串 `p` 的长度时，去掉 `countS` 中记录的最左端超出长度的字符，也就是 `countS[s.charAt(i - n) - 'a']--;`，也就是将最左端表示的字符的次数减 1，从而维持 `countS` 始终只记录长度为 n 的滑动窗口内的字符以及字符出现次数；</span>然后当 `countS` 长度达到 n 且和 `countP` 完全相等的时候，说明当前滑动窗口内的子串和字符串 `p` 是字母异位词。

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int m = s.length();
        int n = p.length();
        List<Integer> result = new ArrayList<>();

        // 如果字符串s的长度小于字符串p，字符串s中不可能存在字符串p的字母异位词，所以直接返回空List
        if (m < n) {
            return result;
        }

        // 初始化 countP 和 countS
        int[] countP = new int[26];
        int[] countS = new int[26];

        // 统计 p 的字符频率
        for (char c : p.toCharArray()) {
            countP[c - 'a']++;
        }

        // 滑动窗口
        for (int i = 0; i < m; i++) {
            // 添加新字符到窗口
            countS[s.charAt(i) - 'a']++;

            // 移除窗口左侧的字符
            if (i >= n) {
                countS[s.charAt(i - n) - 'a']--;
            }

            // 比较 countS 和 countP
            if (i >= n - 1 && matches(countS, countP)) {
                result.add(i - n + 1);
            }
        }

        return result;
    }

    // 辅助方法：比较两个数组是否相等
    private boolean matches(int[] countS, int[] countP) {
        for (int i = 0; i < 26; i++) {
            if (countS[i] != countP[i]) {
                return false;
            }
        }
        return true;
    }
}

```

