# [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

给定一个 `m x n` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)

```txt
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)

```txt
输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

**提示：**

- `m == matrix.length`
- `n == matrix[0].length`
- `1 <= m, n <= 200`
- `-231 <= matrix[i][j] <= 231 - 1`



**进阶：**

- 一个直观的解决方案是使用  `O(*m**n*)` 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O(*m* + *n*)` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？

## 我的求解思路

```c++
/**
1、按行遍历矩阵的每一行中的元素，如果当前行出现0，则停止遍历该行，记录行号、列号，然后遍历下一行；
    遍历完所有行之后，得到所有应该置为零的行和列
2、重新遍历矩阵，修改对应行和列的元素为0（原地修改）

这样时间复杂度为O(mn)，空间复杂度应该是常量。
*/
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        unordered_set<int> rows,cols;
        int m=matrix.size();
        int n=matrix[0].size();
        // 逐行遍历矩阵，记录下零元素所在行和列
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(matrix[j][i]==0){
                    rows.insert(j);
                    cols.insert(i);
                    continue;
                }
            }
        }
        // 将零元素所在列的matrix元素置为0
        for(int i=0;i<n;i++){
            if(cols.contains(i)){
                for(int j=0;j<m;j++){
                    matrix[j][i]=0;
                }
            }
        }
        // 将零元素所在行的matrix元素置为0
        for(int j=0;j<m;j++){
            if(rows.contains(j)){
                for(int i=0;i<n;i++){
                    matrix[j][i]=0;
                }
            }
        }
    }
};
```

点评：我的代码中使用了两个哈希集合rows和cols来存储零元素所在行和列，在最坏情况下（例如矩阵对角线全是0），rows会存储m个元素，cols会存储n个元素，因此我的代码的额外空间消耗并不是常量O(1)，而是O(m+n)。

要实现O(1)的空间复杂度，我们就不能额外开辟空间来记录是否需要置零这一信息，我们可以利用矩阵本身来存储**“某一行或某一列是否需要置零”**的信息。

实现代码如下：

```c++
/**
 * 作用：矩阵置零 (LeetCode 73)
 * 思路：使用矩阵的第一行和第一列作为标记数组，实现 O(1) 空间复杂度。
 * 1. 先判断第一行和第一列原本是否包含 0，记录在 bool 变量中。
 * 2. 遍历其余元素(从1开始)，如果发现 matrix[i][j] == 0，
 * 则将 matrix[i][0] 和 matrix[0][j] 置为 0 作为标记。
 * 3. 再次遍历其余元素，如果对应的行首或列首标记为 0，则将该元素置 0。
 * 4. 最后根据 bool 变量处理第一行和第一列。
 */
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        
        // 1. 记录首行和首列是否原本就包含 0
        bool row0_has_zero = false;
        bool col0_has_zero = false;
        
        // 检查第一列
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                col0_has_zero = true;
                break;
            }
        }
        
        // 检查第一行
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                row0_has_zero = true;
                break;
            }
        }
        
        // 2. 使用第一行和第一列作为标记位
        // 从 (1,1) 开始遍历内部矩阵
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0; // 标记该行
                    matrix[0][j] = 0; // 标记该列
                }
            }
        }
        
        // 3. 根据标记将内部矩阵置零
        // 注意：这里也是从 (1,1) 开始，避免覆盖了第一行/列的标记
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        
        // 4. 最后处理第一行和第一列
        if (row0_has_zero) {
            for (int j = 0; j < n; j++) matrix[0][j] = 0;
        }
        if (col0_has_zero) {
            for (int i = 0; i < m; i++) matrix[i][0] = 0;
        }
    }
};
```

