# [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**示例 3：**

```
输入：intervals = [[4,7],[1,4]]
输出：[[1,7]]
解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。
```

**提示：**

-   `1 <= intervals.length <= 104`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 104`

## 解题思路

```c++
/*
 * 功能：合并重叠区间 (LeetCode 56)
 * 输入：vector<vector<int>> intervals，包含若干个区间的数组
 * 输出：vector<vector<int>>，合并后的区间数组
 * * 实现思路：
 * 1. 排序：首先根据区间的左端点对 intervals 进行升序排序。
 * 2. 遍历：创建一个结果数组 merged。
 * 3. 合并逻辑：
 * - 如果 merged 为空，或者当前区间的左端点 > merged 最后一个区间的右端点：
 * 说明没有重叠，直接将当前区间加入 merged。
 * - 否则（说明有重叠）：
 * 更新 merged 最后一个区间的右端点，取二者右端点的最大值。
 * * 时间复杂度：O(N log N)，主要消耗在排序上。
 * 空间复杂度：O(log N)，排序所需的栈空间。
 */

#include <vector>
#include <algorithm> // 包含 sort 和 max

using namespace std;

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // 0. 特殊情况处理：如果数组为空，直接返回
        if (intervals.empty()) {
            return {};
        }

        // 1. 排序
        // 使用 Lambda 表达式，按照区间的左端点 (interval[0]) 进行升序排序
        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[0] < b[0];
        });

        vector<vector<int>> merged; // 用于存储最终结果

        // 2. 遍历排序后的区间
        for (const auto& interval : intervals) {
            // 左端点 L = interval[0], 右端点 R = interval[1]
            
            // 如果 merged 为空，或者当前区间的左端点 > 上一个合并区间的右端点
            // 说明这两个区间不重叠，直接将当前区间加入结果集
            if (merged.empty() || interval[0] > merged.back()[1]) {
                merged.push_back(interval);
            } 
            // 否则，说明有重叠
            else {
                // 更新上一个区间的右端点
                // 公式：merged.last.end = max(merged.last.end, current.end)
                merged.back()[1] = max(merged.back()[1], interval[1]);
            }
        }

        return merged;
    }
};
```

