# 排序和查找算法总结

---

### **一、比较排序算法**
通过元素间的比较确定顺序，时间复杂度通常下限为 $O(n \log n)$。

1. **冒泡排序 (Bubble Sort)**  
   - 时间复杂度：\(O(n^2)\)  
   - 稳定性：稳定  
   - 描述：重复交换相邻逆序元素。

2. **选择排序 (Selection Sort)**  
   - 时间复杂度：\(O(n^2)\)  
   - 稳定性：不稳定  
   - 描述：每次选择未排序部分的最小元素放到已排序末尾。

3. **插入排序 (Insertion Sort)**  
   - 时间复杂度：\(O(n^2)\)  
   - 稳定性：稳定  
   - 描述：逐个将元素插入已排序部分的正确位置。

4. **希尔排序 (Shell Sort)**  
   - 时间复杂度：\(O(n \log n)\) 到 \(O(n^2)\)  
   - 稳定性：不稳定  
   - 描述：分组插入排序，通过递减增量缩小分组。

5. **快速排序 (Quick Sort)**  
   - 时间复杂度：平均 \(O(n \log n)\)，最坏 \(O(n^2)\)  
   - 稳定性：不稳定  
   - 描述：分治法，选取基准值分区递归排序。

6. **归并排序 (Merge Sort)**  
   - 时间复杂度：\(O(n \log n)\)  
   - 稳定性：稳定  
   - 描述：分治法，递归合并有序子序列。

7. **堆排序 (Heap Sort)**  
   - 时间复杂度：\(O(n \log n)\)  
   - 稳定性：不稳定  
   - 描述：利用最大堆/最小堆结构排序。

8. **树形排序 (Tree Sort)**  
   - 时间复杂度：\(O(n \log n)\)  
   - 稳定性：稳定（若用平衡树）  
   - 描述：构建二叉搜索树后中序遍历。

9. **鸡尾酒排序 (Cocktail Shaker Sort)**  
   - 时间复杂度：\(O(n^2)\)  
   - 稳定性：稳定  
   - 描述：双向冒泡排序，交替方向遍历。

10. **侏儒排序 (Gnome Sort)**  
    - 时间复杂度：\(O(n^2)\)  
    - 稳定性：稳定  
    - 描述：类似插入排序，通过交换相邻元素逐步前移。

11. **循环排序 (Cycle Sort)**  
    - 时间复杂度：\(O(n^2)\)  
    - 稳定性：不稳定  
    - 描述：通过循环分解排列减少写操作次数。

12. **内省排序 (Introsort)**  
    - 时间复杂度：\(O(n \log n)\)  
    - 稳定性：不稳定  
    - 描述：混合快速排序、堆排序和插入排序。

13. **奇偶排序 (Odd-Even Sort)**  
    - 时间复杂度：\(O(n^2)\)  
    - 稳定性：稳定  
    - 描述：并行算法基础，交替比较奇偶索引元素。

14. **梳排序 (Comb Sort)**  
    - 时间复杂度：\(O(n^2)\)，优化后接近 \(O(n \log n)\)  
    - 稳定性：不稳定  
    - 描述：改进冒泡排序，以递减步长比较元素。

15. **图书馆排序 (Library Sort)**  
    - 时间复杂度：\(O(n \log n)\)  
    - 稳定性：稳定  
    - 描述：插入排序优化，预留间隙加速插入。

---

### **二、非比较排序算法**
利用数据特性（如范围、分布）排序，突破比较排序下限。

1. **计数排序 (Counting Sort)**  
   - 时间复杂度：\(O(n + k)\)（\(k\) 为数据范围）  
   - 稳定性：稳定  
   - 描述：统计元素频率后累加输出。

2. **基数排序 (Radix Sort)**  
   - 时间复杂度：\(O(n \cdot k)\)（\(k\) 为最大位数）  
   - 稳定性：稳定（通常基于计数排序实现）  
   - 描述：按位分配收集，从低位到高位排序。

3. **桶排序 (Bucket Sort)**  
   - 时间复杂度：\(O(n + k)\)（理想情况下）  
   - 稳定性：稳定  
   - 描述：将元素分到有限桶内，各桶单独排序后合并。

4. **鸽巢排序 (Pigeonhole Sort)**  
   - 时间复杂度：\(O(n + k)\)  
   - 稳定性：稳定  
   - 描述：类似计数排序，适用于元素值范围小的情况。

---

### **三、分布式与并行排序**
针对大规模数据或并行计算设计。

1. **样本排序 (Sample Sort)**  
   - 描述：并行快速排序变体，通过采样确定分区点。

2. **桶排序并行版**  
   - 描述：将数据分到多个桶后并行处理。

3. **MapReduce 排序**  
   - 描述：分布式环境下通过 Map 和 Reduce 阶段排序。

---

### **四、低效或理论性排序**
实际应用少，但具有理论意义或趣味性。

1. **Bogo 排序 (Bogo Sort)**  
   - 时间复杂度：平均 \(O(n \cdot n!)\)  
   - 描述：随机打乱序列直到有序。

2. **慢排序 (Slow Sort)**  
   - 时间复杂度：\(O(n^{\log n})\)  
   - 描述：递归故意低效，证明分治法不总高效。

3. **珠排序 (Bead Sort)**  
   - 时间复杂度：\(O(n \sqrt{n})\)  
   - 描述：利用重力模拟珠子下落排序。

4. **Stooge 排序**  
   - 时间复杂度：\(O(n^{\log 3/\log 1.5})\)  
   - 描述：递归分治，前 2/3 与后 2/3 分别排序。

---

### **五、混合排序算法**
结合多种排序策略优化性能。

1. **Timsort**  
   - 时间复杂度：\(O(n \log n)\)  
   - 稳定性：稳定  
   - 描述：归并排序与插入排序结合，Python 和 Java 默认排序算法。

2. **块排序 (Block Sort)**  
   - 描述：分块后内部插入排序，外部归并排序。

---

### **六、特殊数据结构排序**
针对特定数据结构的优化算法。

1. **链表排序**  
   - 常用方法：归并排序（适应链表特性）。

2. **外部排序 (External Sort)**  
   - 描述：处理超出内存的数据，如多路归并排序。

---

### **总结**
- **常见算法**：快速排序、归并排序、堆排序、插入排序、计数排序、基数排序。  
- **特殊场景**：Timsort（混合）、外部排序（大数据）、Bogo 排序（理论）。  
- **稳定性关键算法**：归并排序、插入排序、计数排序、基数排序。  

以上覆盖了所有主流及小众排序算法，确保无遗漏。







# 排序算法

## 冒泡排序

```cpp
class BubbleSort {
public:
    // 标准冒泡排序
    static void bubbleSort(std::vector<int>& arr) {
        int n = arr.size();
        
        // 外层循环：控制总遍历轮数（最大元素冒泡到数组末尾最多交换n-1次）
        for (int i = 0; i < n - 1; i++) {
            // 优化：增加标志位，如果某一轮没有发生交换，说明已经有序
            bool swapped = false;
            
            // 内层循环：每轮比较并交换相邻元素
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {  // 冒泡排序稳定性的保证在于只有后面元素比当前元素大才交换，等于的时候不交换
                    // 交换元素
                    std::swap(arr[j], arr[j + 1]);
                    swapped = true;
                }
            }
            
            // 如果没有发生交换，说明数组已经有序
            if (!swapped) break;
        }
    }

    // 打印数组
    static void printArray(const std::vector<int>& arr) {
        for (int num : arr) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    }
};
```



#### 冒泡排序性能分析

##### 1. 时间复杂度

- 最好情况：O(n)
  - 当输入数组已经完全有序时
  - 通过 `swapped` 标志位可以提前终止排序
- 最坏情况：O(n²)
  - 当输入数组完全逆序时
- **平均情况**：O(n²)

##### 2. 空间复杂度

- **空间复杂度**：O(1)
- 原地排序算法，只使用常数额外空间

##### 3. 稳定性

- **稳定排序算法**
- 相等元素的相对位置不会改变

##### 4. 特点与评价

- **优点**：
  - 实现简单
  - 空间复杂度低
  - 对小规模数据有一定优势
- **缺点**：
  - 时间复杂度高，不适合大规模数据
  - 每次只交换相邻元素，效率较低

##### 5. 适用场景

- 小型数据集，近乎有序的数组，教学和算法学习

##### 6. 性能优化

- 增加 `swapped` 标志位（已在代码中实现）
- 记录最后一次交换位置，减少比较次数
- 对于大规模数据，不推荐使用

通过这个实现，您可以看到冒泡排序的核心思想：**反复遍历数组，比较相邻元素，将最大（或最小）元素逐步 "冒泡" 到数组末尾。**





## 选择排序

选择排序的核心思想在于：遍历数组中前 $n-1$ 个位置，首先假设第一个位置 $i$ 的元素为最小元素，然后不断遍历从 $i$ 到数组末尾的所有元素，找到最小的来代替位置 $i$ 的元素，如果有更小的，则与位置 $i$ 的元素交换，否则位置 $i$ 的元素就是最小元素，该位置的元素就确定下来了，然后 $i$ 加 1，继续确定下一个位置的元素。

```cpp
class SelectionSort {
public:
    // 选择排序算法实现
    static void selectionSort(std::vector<int>& arr) {
        int n = arr.size();
        
        // 外层循环：控制选择的起始位置
        for (int i = 0; i < n - 1; i++) {
            // 假设当前位置为最小元素的索引
            int minIndex = i;
            
            // 内层循环：找出当前未排序区间的最小元素，i之前为已排好序区间，i之后为未排序区间
            for (int j = i + 1; j < n; j++) {
                // 如果找到更小的元素，更新最小元素索引
                if (arr[j] < arr[minIndex]) {	  
                    minIndex = j;
                }
            }
            
            // 将找到的最小元素与当前位置交换
            // 如果minIndex与i不同，才进行交换
            if (minIndex != i) {
                std::swap(arr[i], arr[minIndex]);
            }
        }
    }

    // 打印数组
    static void printArray(const std::vector<int>& arr) {
        for (int num : arr) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    }
};
```

#### 代码解析

1. `minIndex = i`：假设当前位置为最小元素
2. 内层循环找出未排序区间的最小元素
3. 如果找到更小元素，更新 `minIndex`
4. 交换当前位置与最小元素
5. 通过减少不必要的交换来优化性能

#### 选择排序性能分析

#### 1. 时间复杂度

- 最好情况：$O(n²)$
  - 即使数组已经有序，仍需要完整遍历并比较
- 最坏情况：$O(n²)$
  - 无论输入数据的初始状态如何
- **平均情况**：$O(n²)$

#### 2. 空间复杂度

- **空间复杂度**：$O(1)$
- 原地排序算法
- 只使用常数额外空间（用于存储最小元素索引）

#### 3. 稳定性

- **不稳定排序算法**
- 可能改变相等元素的相对位置
- 示例：[5(1), 5(2), 2] 排序后可能变成 [2, 5(2), 5(1)]

#### 4. 特点与评价

- **优点**：
  - 实现简单
  - 空间复杂度低
  - 交换次数最少（与冒泡排序相比）
- **缺点**：
  - 时间复杂度高，不适合大规模数据
  - 固定需要 O(n²)的比较次数
  - 不稳定排序

#### 5. 算法原理

1. 将数组分为已排序区间和未排序区间
2. 每次从未排序区间选择最小元素
3. 将最小元素放到已排序区间末尾
4. 重复上述过程直到全部排序完成

#### 6. 适用场景

- 小规模数据集，对交换次数敏感的场景，内存空间受限的环境，算法学习和教学

#### 7. 性能对比

相比冒泡排序：

- 交换次数更少
- 性能略好一些
- 但时间复杂度仍为 O(n²)

#### 8. 改进方向

- 对于大规模数据，建议使用更高效的排序算法
- 如快速排序、归并排序、堆排序等

选择排序是一种直观但效率不高的排序算法，主要适用于教学和小规模数据排序。对于大型数据集，推荐使用更高效的排序算法。





## 插入排序

插入排序(Insertion Sort)是一种简单直观的排序算法，其工作原理类似于我们整理扑克牌的方式：

1. **基本思想**：将数组分为已排序部分和未排序部分，每次从未排序部分取出一个元素，将其插入到已排序部分的正确位置。

2. **具体步骤**：
   - 从第二个元素开始（第一个元素默认已排序）
   - 取出当前元素，与前面已排序的元素从后向前比较
   - 如果当前元素小于比较的元素，则将比较的元素后移一位
   - 重复这个过程，直到找到合适的位置插入当前元素
   - 对数组中所有元素重复上述过程

3. **时间复杂度**：
   - 最优情况（已排序数组）：$O(n)$
   - 最差情况（逆序数组）：$O(n²)$
   - 平均情况：$O(n²)$

4. **空间复杂度**：$O(1)$（原地排序）

5. **稳定性**：稳定排序算法（相同元素的相对位置不变）

### C++实现代码（带详细注释）

```cpp
#include <iostream>
#include <vector>

/**
 * 插入排序函数
 * @param arr 待排序的数组（使用vector容器）
 */
void insertionSort(std::vector<int>& arr) {
    // 获取数组长度
    int n = arr.size();
    
    // 从第二个元素开始遍历（i=1），因为第一个元素默认已排序
    for (int i = 1; i < n; i++) {
        // 保存当前需要插入的元素值（防止被覆盖）
        int key = arr[i];
        
        // j表示已排序部分的最后一个元素的索引
        int j = i - 1;
        
        /* 将当前元素(key)与已排序部分的元素从后向前比较
         * 如果已排序元素大于key，则将该元素后移一位
         * 直到找到key的正确位置或到达数组开头
         */
        while (j >= 0 && key < arr[j]) {
            arr[j + 1] = arr[j]; // 将arr[j]元素后移
            j--;                 // 继续向前比较
        }
        
        // 将key插入到正确的位置（j+1是因为循环结束时j可能减1过多）
        arr[j + 1] = key;
        
        // 可选：打印每轮排序后的数组状态（用于理解算法过程）
        /*
        std::cout << "第" << i << "轮排序后: ";
        for (int num : arr) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
        */
    }
}

int main() {
    // 测试数据
    std::vector<int> arr = {12, 11, 13, 5, 6};
    
    // 打印排序前的数组
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 调用插入排序函数
    insertionSort(arr);
    
    // 打印排序后的数组
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 代码执行过程示例

以数组 `[12, 11, 13, 5, 6]` 为例：

1. **初始状态**：[12] | 11, 13, 5, 6
   - 取出 11，与 12 比较，12 > 11，12 后移，插入 11 → [11, 12] | 13, 5, 6

2. **第二轮**：[11, 12] | 13, 5, 6
   - 取出 13，与 12 比较，12 < 13，直接插入 → [11, 12, 13] | 5, 6

3. **第三轮**：[11, 12, 13] | 5, 6
   - 取出 5，依次与 13、12、11 比较，都 > 5，全部后移，插入 5 → [5, 11, 12, 13] | 6

4. **第四轮**：[5, 11, 12, 13] | 6
   - 取出 6，与 13 比较，13 > 6，后移；与 12 比较，12 > 6，后移；与 11 比较，11 > 6，后移；与 5 比较，5 < 6，插入 → [5, 6, 11, 12, 13]

### 优化方向

虽然插入排序简单，但仍有优化空间：

1. **二分查找插入位置**：可以使用二分查找来快速找到插入位置，减少比较次数（但移动元素的次数不变）
2. **希尔排序**：插入排序的改进版，通过分组插入排序来提高效率

插入排序在小规模数据或基本有序的数据上表现良好，常被用作其他高级排序算法（如快速排序、归并排序）在小规模数据时的优化手段。







## 希尔排序

希尔排序(Shell Sort)是插入排序的一种高效改进版本，也称为 "缩小增量排序"，由 Donald Shell 于 1959 年提出。

### 基本思想

1. **分组插入**：将原始数组分割成若干子序列，子序列由相隔某个 "增量" 的元素组成
2. **逐步缩小增量**：对每个子序列进行插入排序，然后逐步减小增量并重复这个过程
3. **最终增量为一**：当增量减至 1 时，整个数组作为一个序列来处理，此时数组已经基本有序，插入排序效率很高

### 增量序列

增量序列的选择对希尔排序的性能有很大影响。常见的增量序列有：
- Shell 原始序列：$n/2, n/4, ..., 1$
- Hibbard 序列：$1, 3, 7, ..., 2^k-1$
- Sedgewick 序列：更复杂的组合序列

### 时间复杂度

希尔排序的时间复杂度取决于增量序列的选择：
- 最坏情况：$O(n^2)$（使用 Shell 原始序列）
- 最好情况：$O(n\log n)$（使用某些优化增量序列）
- 平均情况：根据增量序列不同而变化

### 空间复杂度

O(1)（原地排序）

### 稳定性

不稳定排序算法（相同元素可能因分组而改变相对位置）

### C++实现代码（带详细注释）

```cpp
#include <iostream>
#include <vector>

/**
 * 希尔排序函数
 * @param arr 待排序的数组（使用vector容器）
 */
void shellSort(std::vector<int>& arr) {
    // 获取数组长度
    int n = arr.size();
    
    // 初始增量gap设置为数组长度的一半，然后逐步缩小gap
    for (int gap = n/2; gap > 0; gap /= 2) {
        // 从gap位置开始，对每个子序列进行插入排序
        for (int i = gap; i < n; i++) {
            // 保存当前需要插入的元素值
            int temp = arr[i];
            
            // j表示当前元素在子序列中的前一个元素的索引
            int j;
            
            /* 对子序列进行插入排序
             * 将当前元素与子序列中前面的元素比较
             * 如果前面的元素较大，则后移
             */
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];	  // 当前元素i在子序列中的前一个元素，如果当前元素i在子序列中的前一个元素比元素i大，则继续向前（减去gap）寻找，直到找到比当前元素i小的，此时j的位置就是元素i在子序列中排序的正确位置
            }
            
            // 将temp（也就是arr[i]的值）插入到正确的位置
            arr[j] = temp;
        }
        
        // 可选：打印每轮排序后的数组状态（用于理解算法过程）
        /*
        std::cout << "增量" << gap << "排序后: ";
        for (int num : arr) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
        */
    }
}

int main() {
    // 测试数据
    std::vector<int> arr = {12, 34, 54, 2, 3, 8, 11, 25, 7};
    
    // 打印排序前的数组
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 调用希尔排序函数
    shellSort(arr);
    
    // 打印排序后的数组
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 代码执行过程示例

以数组 `[12, 34, 54, 2, 3, 8, 11, 25, 7]` 为例（初始增量 gap = 9/2 = 4）：

1. **第一轮（gap = 4）**：
   - 分组：[12,3,7], [34,8], [54,11], [2,25]
   - 对各组插入排序后：[3,8,11,2,7,12,25,34,54]

2. **第二轮（gap = 2）**：
   - 分组：[3,11,7,25,54], [8,2,12,34]
   - 对各组插入排序后：[3,2,7,8,11,12,25,34,54]

3. **第三轮（gap = 1）**：
   - 整个数组作为一组进行插入排序
   - 最终结果：[2,3,7,8,11,12,25,34,54]

### 优化方向

1. **增量序列选择**：使用更高效的增量序列（如 Hibbard、Sedgewick 序列）可以显著提高性能
2. **结合其他排序**：对于小子序列可以使用更高效的排序算法
3. **并行化**：不同子序列的排序可以并行处理

### 与其他排序算法的比较

1. **与插入排序比较**：
   - 希尔排序通过分组大大减少了数据移动的次数
   - 在中等规模数据上表现更好

2. **与快速排序比较**：
   - 希尔排序不需要递归，空间复杂度更低
   - 但快速排序在平均情况下更快

希尔排序适用于 ==中等规模== 的数据排序，特别是在内存受限的环境中，因为它只需要 O(1)的额外空间。





## 快速排序

快速排序(Quick Sort)是由 Tony Hoare 于 1960 年提出的一种高效的排序算法，采用分治策略。

### 基本思想

1. **分治策略**：
   - **分解**：从数组中选择一个 "基准" 元素(pivot)，将数组分为两部分
   - **解决**：递归地对两个子数组进行快速排序
   - **合并**：由于是原地排序，不需要合并步骤

2. **分区过程**：
   - 所有比基准小的元素移到基准前面
   - 所有比基准大的元素移到基准后面
   - 基准元素最终位于正确的位置

3. **基准选择**：
   - ==通常选择第一个、最后一个或中间元素作为基准==
   - 随机选择基准可以避免最坏情况

### 时间复杂度

- **最优情况**：$O(n \log n)$（每次分区都平分数组）
- **最坏情况**：$O(n^2)$（每次分区都极度不平衡）
- **平均情况**：$O(n \log n)$

### 空间复杂度

- **最优情况**：$O(\log n)$（递归调用栈）
- **最坏情况**：$O(n)$（极度不平衡分区）

### 稳定性

不稳定排序算法（相同元素可能因交换而改变相对位置）

### C++实现代码（带详细注释）

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 用于swap函数

/**
 * 分区函数 - 将数组分为两部分，返回基准元素的最终位置
 * @param arr 待排序数组
 * @param low 起始索引
 * @param high 结束索引
 * @return 基准元素的正确位置索引
 */
int partition(std::vector<int>& arr, int low, int high) {
    // 选择最右边的元素作为基准(pivot)
    int pivot = arr[high];
    
    // i指向小于基准的子数组的最后一个元素
    int i = low - 1;
    
    // 遍历从low到high-1的所有元素
    for (int j = low; j < high; j++) {
        // 如果当前元素小于或等于基准
        if (arr[j] <= pivot) {  // 每找到一个比基准小的元素，就将i加1，然后将当前比基准小的元素arr[j]交换到左半部分，遍历结束后，比基准小的元素就全部在左半边，比基准大的元素自然就都到了右半边
            i++; // 扩大小于基准的子数组
            std::swap(arr[i], arr[j]); // 将当前元素arr[j]交换到小于基准的区域
        }
    }
    
    // 将基准元素交换到正确位置(i+1)
    std::swap(arr[i + 1], arr[high]);
    
    // 返回基准的最终位置
    return i + 1;
}

/**
 * 快速排序主函数
 * @param arr 待排序数组
 * @param low 起始索引
 * @param high 结束索引
 */
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        // pi是分区索引，arr[pi]现在在正确位置
        int pi = partition(arr, low, high);
        
        // 递归排序分区前的子数组
        quickSort(arr, low, pi - 1);
        
        // 递归排序分区后的子数组
        quickSort(arr, pi + 1, high);
    }
}

/**
 * 快速排序的包装函数，简化调用
 * @param arr 待排序数组
 */
void quickSort(std::vector<int>& arr) {
    quickSort(arr, 0, arr.size() - 1);
}

int main() {
    // 测试数据
    std::vector<int> arr = {10, 7, 8, 9, 1, 5};
    
    // 打印排序前的数组
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 调用快速排序函数
    quickSort(arr);
    
    // 打印排序后的数组
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 代码执行过程示例

以数组 `[10, 7, 8, 9, 1, 5]` 为例：

1. **初始调用**：quickSort(arr, 0, 5)
   - 选择 pivot = 5（最后一个元素）
   - 分区过程：
     - i =-1, j = 0: 10 > 5 → 不交换
     - j = 1: 7 > 5 → 不交换
     - j = 2: 8 > 5 → 不交换
     - j = 3: 9 > 5 → 不交换
     - j = 4: 1 < 5 → i = 0, 交换 7 和 1 → [10,1,8,9,7,5]
   - 最后交换 arr [1] 和 pivot → [1,5,8,9,7,10]
   - 返回 pi = 1

2. **左子数组**：quickSort(arr, 0, 0) → 直接返回（只有一个元素）

3. **右子数组**：quickSort(arr, 2, 5)
   - 选择 pivot = 10
   - 分区过程：
     - i = 1, j = 2: 8 < 10 → i = 2 → [1,5,8,9,7,10]
     - j = 3: 9 < 10 → i = 3 → [1,5,8,9,7,10]
     - j = 4: 7 < 10 → i = 4 → [1,5,8,9,7,10]
   - 最后交换 arr [5] 和 pivot → 无变化
   - 返回 pi = 5

4. **继续递归**...最终得到排序后的数组 [1,5,7,8,9,10]

### 优化方向

1. **小数组优化**：对于小数组（如 n < 10），切换到插入排序
2. **三数取中法**：选择第一个、中间和最后一个元素的中位数作为基准
3. **随机化基准**：随机选择基准元素避免最坏情况
4. **三向切分**：处理大量重复元素的情况
5. **尾递归优化**：减少递归深度

### 与其他排序算法的比较

1. **与归并排序比较**：
   - 都是分治算法，平均 $O(n \log n)$
   - 快速排序是原地排序，空间效率更高
   - 归并排序稳定且最坏情况也是 $O(n \log n)$

2. **与堆排序比较**：
   - 都是 $O(n \log n)$ 算法
   - 快速排序通常更快（常数因子更小）
   - 堆排序最坏情况也是 $O(n \log n)$

快速排序是实际应用中最快的通用排序算法之一，被许多语言的标准库采用（如 C++的 std:: sort）。







## 归并排序

归并排序(Merge Sort)是一种基于分治策略的高效排序算法，由John von Neumann于1945年发明。

### 基本思想

1. **分治策略**：
   - **分解**：将数组递归地分成两半，直到子数组长度为1
   - **解决**：对每个子数组进行排序（长度为1的数组自然有序）
   - **合并**：将两个已排序的子数组合并成一个有序数组

2. **合并过程**：
   - 比较两个子数组的首元素
   - 每次取较小的元素放入结果数组
   - 当一个子数组用尽后，将另一个子数组剩余部分直接复制

3. **关键特点**：
   - 稳定排序算法（相同元素的相对位置不变）
   - 需要额外的存储空间（非原地排序）

### 时间复杂度

- **最优情况**：$O(n \log n)$
- **最坏情况**：$O(n \log n)$
- **平均情况**：$O(n \log n)$

### 空间复杂度

$O(n)$（需要与原始数组等大的临时空间）

### C++实现代码（带详细注释）

```cpp
#include <iostream>
#include <vector>

/**
 * 合并两个已排序的子数组
 * @param arr 原始数组
 * @param left 左子数组起始索引
 * @param mid 左子数组结束索引/右子数组起始索引-1
 * @param right 右子数组结束索引
 * @param temp 临时数组用于合并
 */
void merge(std::vector<int>& arr, int left, int mid, int right, std::vector<int>& temp) {
    int i = left;    // 左子数组起始位置
    int j = mid + 1; // 右子数组起始位置
    int k = 0;       // 临时数组索引

    // 比较两个子数组的元素，将较小的放入临时数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {  // 保持稳定性（<= 而不是 <）
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }

    // 将左子数组剩余元素复制到临时数组
    while (i <= mid) {
        temp[k++] = arr[i++];
    }

    // 将右子数组剩余元素复制到临时数组
    while (j <= right) {
        temp[k++] = arr[j++];
    }

    // 将临时数组中的合并结果复制回原数组
    for (i = 0; i < k; i++) {
        arr[left + i] = temp[i];
    }
}

/**
 * 归并排序递归函数
 * @param arr 待排序数组
 * @param left 当前子数组起始索引
 * @param right 当前子数组结束索引
 * @param temp 临时数组
 */
void mergeSort(std::vector<int>& arr, int left, int right, std::vector<int>& temp) {
    if (left < right) {  // 子数组长度大于1时才需要排序
        int mid = left + (right - left) / 2;  // 防止溢出的中间位置计算

        // 递归排序左半部分
        mergeSort(arr, left, mid, temp);

        // 递归排序右半部分
        mergeSort(arr, mid + 1, right, temp);

        // 合并两个已排序的子数组
        merge(arr, left, mid, right, temp);
    }
}

/**
 * 归并排序的包装函数，简化调用
 * @param arr 待排序数组
 */
void mergeSort(std::vector<int>& arr) {
    // 创建临时数组，避免在递归中重复创建
    std::vector<int> temp(arr.size());
    mergeSort(arr, 0, arr.size() - 1, temp);
}

int main() {
    // 测试数据
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};

    // 打印排序前的数组
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // 调用归并排序函数
    mergeSort(arr);

    // 打印排序后的数组
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 代码执行过程示例

以数组 `[12, 11, 13, 5, 6, 7]` 为例：

1. **初始分割**：
   - 分成 [12,11,13] 和 [5,6,7]

2. **递归分割左半部分**：
   - [12,11,13] → [12] 和 [11,13]
   - [11,13] → [11] 和 [13]（基本情形）

3. **合并左半部分**：
   - 合并 [11] 和 [13] → [11,13]
   - 合并 [12] 和 [11,13] → [11,12,13]

4. **递归分割右半部分**：
   - [5,6,7] → [5] 和 [6,7]
   - [6,7] → [6] 和 [7]（基本情形）

5. **合并右半部分**：
   - 合并 [6] 和 [7] → [6,7]
   - 合并 [5] 和 [6,7] → [5,6,7]

6. **最终合并**：
   - 合并 [11,12,13] 和 [5,6,7] → [5,6,7,11,12,13]

### 关键点解析

1. **稳定性保证**：
   - 在merge函数中使用 `arr[i] <= arr[j]` 而不是 `<`，确保相等元素的原始顺序不变

2. **防止整数溢出**：
   - 计算mid使用 `left + (right - left) / 2` 而非 `(left + right) / 2`

3. **临时数组优化**：
   - 在外部创建临时数组，避免递归中反复创建销毁

4. **递归终止条件**：
   - `left < right` 确保子数组长度大于1时才继续分割

### 优化方向

1. **小数组优化**：对小规模子数组使用插入排序
2. **迭代实现**：避免递归调用栈的开销
3. **原地归并**：减少空间使用（但实现复杂且性能可能下降）
4. **并行化**：利用多线程处理不同子数组

### 与其他排序算法的比较

1. **与快速排序比较**：
   - 都是O(n log n)算法
   - 归并排序稳定，快速排序不稳定
   - 归并排序需要额外空间，快速排序是原地排序
   - 归并排序最坏情况也是O(n log n)，快速排序最坏O(n²)

2. **与堆排序比较**：
   - 都是O(n log n)算法
   - 归并排序稳定，堆排序不稳定
   - 归并排序需要额外空间，堆排序是原地排序

归并排序特别适合以下场景：
- 需要稳定排序时
- 处理链表排序（只需要O(1)额外空间）
- 外部排序（数据量太大无法全部装入内存）





## 堆排序

堆排序(Heap Sort)是一种基于完全二叉树（堆数据结构）的高效排序算法，由J.W.J. Williams于1964年提出。

### 基本思想

1. **堆的定义**：
   - 完全二叉树
   - 每个节点的值都大于等于（最大堆）或小于等于（最小堆）其子节点的值

2. **排序过程**：
   - **建堆**：将无序数组构建成最大堆
   - **排序**：重复从堆顶取出最大值（与堆末尾交换），然后调整剩余元素为新堆

3. **关键操作**：
   - **堆化(Heapify)**：维护堆性质的过程
   - **下沉(Sink)**：节点向下调整的过程

### 时间复杂度

- **建堆**：O(n)
- **每次堆化**：O(log n)
- **总复杂度**：O(n log n)

### 空间复杂度

O(1)（原地排序）

### 稳定性

不稳定排序算法（相同元素可能因交换而改变相对位置）

### C++实现代码（带详细注释）

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 用于swap函数

/**
 * 堆化函数 - 维护最大堆性质
 * @param arr 待堆化的数组
 * @param n 堆的大小
 * @param i 当前需要堆化的节点索引
 */
// 将以索引为i的节点为根节点的子树转化为最大堆
void heapify(std::vector<int>& arr, int n, int i) {
    int largest = i;       // 初始化最大值为当前节点
    int left = 2 * i + 1;  // 左子节点索引
    int right = 2 * i + 2; // 右子节点索引

    // 如果左子节点存在且大于当前最大值
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // 如果右子节点存在且大于当前最大值
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // 如果最大值不是当前节点
    if (largest != i) {
        std::swap(arr[i], arr[largest]); // 交换节点值
        heapify(arr, n, largest);        // 递归堆化受影响的子树
    }
}

/**
 * 堆排序主函数
 * @param arr 待排序数组
 */
void heapSort(std::vector<int>& arr) {
    int n = arr.size();

    // 1. 构建最大堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // 2. 逐个提取堆顶元素（最大值）
    for (int i = n - 1; i > 0; i--) {
        // 将当前堆顶（最大值）移到数组末尾
        std::swap(arr[0], arr[i]);
        
        // 对剩余元素重新堆化（堆大小减1）
        heapify(arr, i, 0);  // i为去除堆顶元素后当前堆的元素个数
    }
}

int main() {
    // 测试数据
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};
    
    // 打印排序前的数组
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 调用堆排序函数
    heapSort(arr);
    
    // 打印排序后的数组
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 代码执行过程示例

以数组 `[12, 11, 13, 5, 6, 7]` 为例：

1. **建堆阶段**：
   - 初始数组对应的完全二叉树：
     ```
         12
        /  \
       11   13
      / \   /
     5  6 7
     ```
   - 从最后一个非叶子节点（索引2）开始堆化：
     - 堆化节点13（已经是最大值）
     - 堆化节点11 → 与6交换
     - 堆化节点12 → 与13交换
   - 最终最大堆：
     ```
         13
        /  \
       11   12
      / \   /
     5  6 7
     ```

2. **排序阶段**：
   - 交换堆顶13与末尾7 → [7,11,12,5,6,13]
   - 堆化前5个元素：
     ```
         12
        /  \
       11   7
      / \
     5  6
     ```
   - 交换堆顶12与末尾6 → [6,11,7,5,12,13]
   - 重复此过程直到完全有序

### 关键点解析

1. **堆化过程**：
   - 比较节点与其左右子节点
   - 如果子节点更大则交换
   - 递归处理被交换的子节点

2. **建堆优化**：
   - 从n/2-1开始（最后一个非叶子节点）
   - 自底向上堆化，减少操作次数

3. **排序过程**：
   - 每次将堆顶（最大值）交换到数组末尾
   - 堆大小减1
   - 只需堆化根节点即可维护堆性质

### 优化方向

1. **迭代实现堆化**：减少递归调用开销
2. **多叉堆**：使用d叉堆（d>2）可能提高缓存性能
3. **内省排序**：结合快速排序和堆排序的优点
4. **并行化**：并行建堆和堆化

### 与其他排序算法的比较

1. **与快速排序比较**：
   - 都是O(n log n)算法
   - 堆排序最坏情况也是O(n log n)，快速排序最坏O(n^2)
   - 堆排序不稳定，快速排序通常更快（常数因子更小）

2. **与归并排序比较**：
   - 都是O(n log n)算法
   - 堆排序是原地排序，归并排序需要额外空间
   - 堆排序不稳定，归并排序稳定

堆排序特别适合以下场景：
- 需要保证最坏情况下O(n log n)复杂度
- 内存受限的环境（原地排序）
- 需要同时实现优先队列的情况





## 树形排序

树形排序（Tree Sort）是一种基于二叉搜索树（BST）的排序算法，它利用BST的中序遍历有序性来实现排序。

### 基本思想

1. **构建BST**：
   - 将待排序元素逐个插入二叉搜索树中
   - 保持BST性质：左子树所有节点值 < 根节点值 < 右子树所有节点值

2. **中序遍历**：
   - 对构建好的BST进行中序遍历（左-根-右）
   - 按升序获得所有元素

3. **时间复杂度分析**：
   - **最优情况**（平衡BST）：$O(n \log n)$构建 + $O(n)$遍历 = $O(n \log n)$
   - **最差情况**（退化成链表）：$O(n^2)$构建 + $O(n)$遍历 = $O(n^2)$
   - **平均情况**：$O(n \log n)$

4. **空间复杂度**：$O(n)$（需要存储树结构）

5. **稳定性**：稳定（取决于插入顺序的维护方式）

### C++实现代码（带详细注释）

```cpp
#include <iostream>
#include <vector>
#include <memory> // 用于智能指针

// 二叉搜索树节点结构
struct TreeNode {
    int val;
    std::shared_ptr<TreeNode> left;
    std::shared_ptr<TreeNode> right;
    
    // 构造函数
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

/**
 * 向BST插入新节点（递归实现）
 * @param root 当前子树根节点
 * @param val 要插入的值
 * @return 插入后的子树根节点
 */
std::shared_ptr<TreeNode> insert(std::shared_ptr<TreeNode> root, int val) {
    // 如果当前子树为空，创建新节点
    if (!root) {
        return std::make_shared<TreeNode>(val);
    }
    
    // 递归插入左子树或右子树
    if (val <= root->val) {  // 注意<=保持稳定性（相同元素放左边）
        root->left = insert(root->left, val);
    } else {
        root->right = insert(root->right, val);
    }
    
    return root;
}

/**
 * 中序遍历BST并将结果存入数组
 * @param root 当前访问的节点
 * @param result 存储结果的数组
 */
void inOrderTraversal(const std::shared_ptr<TreeNode>& root, std::vector<int>& result) {
    if (!root) return;
    
    // 左子树 -> 根节点 -> 右子树
    inOrderTraversal(root->left, result);
    result.push_back(root->val);
    inOrderTraversal(root->right, result);
}

/**
 * 树形排序主函数
 * @param arr 待排序数组
 */
void treeSort(std::vector<int>& arr) {
    std::shared_ptr<TreeNode> root = nullptr;
    
    // 1. 构建BST
    for (int num : arr) {
        root = insert(root, num);
    }
    
    // 2. 中序遍历获取排序结果
    arr.clear(); // 清空原数组
    inOrderTraversal(root, arr);
}

int main() {
    // 测试数据
    std::vector<int> arr = {5, 3, 7, 2, 4, 6, 8};
    
    // 打印排序前的数组
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 调用树形排序
    treeSort(arr);
    
    // 打印排序后的数组
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### 代码执行过程示例

以数组 `[5, 3, 7, 2, 4, 6, 8]` 为例：

1. **构建BST**：
   - 插入5 → 根节点
   - 插入3 → 5的左子节点
   - 插入7 → 5的右子节点
   - 插入2 → 3的左子节点
   - 插入4 → 3的右子节点
   - 插入6 → 7的左子节点
   - 插入8 → 7的右子节点
   ```
       5
      / \
     3   7
    / \ / \
   2  4 6 8
   ```

2. **中序遍历**：
   - 访问顺序：2 → 3 → 4 → 5 → 6 → 7 → 8
   - 排序结果：[2, 3, 4, 5, 6, 7, 8]

#### 关键点解析

1. **BST插入规则**：
   - 值≤当前节点 → 左子树
   - 值>当前节点 → 右子树
   - 使用`<=`比较保持稳定性

2. **中序遍历性质**：
   - 左子树 → 根节点 → 右子树
   - 对BST产生升序序列

3. **智能指针使用**：
   - `shared_ptr`自动管理内存
   - 避免手动内存分配/释放

#### 优化方向

1. **平衡BST**：
   - 使用AVL树或红黑树保证平衡
   - 最坏情况下仍保持$O(n \log n)$

2. **迭代实现**：
   - 用栈模拟递归中序遍历
   - 减少函数调用开销

3. **原地构建**：
   - 将数组原地转换为BST（复杂）

4. **并行插入**：
   - 对大数据集可并行构建子树

#### 与其他排序算法比较

1. **与快速排序比较**：
   - 都是基于比较的排序
   - 树排序最坏$O(n^2)$，快速排序可通过优化避免
   - 树排序稳定，快速排序不稳定

2. **与堆排序比较**：
   - 都基于树结构
   - 堆排序原地排序，树排序需要额外空间
   - 堆排序不稳定

树排序适合以下场景：
- 需要稳定排序
- 数据动态变化（BST支持高效插入/删除）
- 已部分有序的数据（构建BST更高效）

### 扩展：平衡BST实现

以下是使用红黑树（自平衡二叉搜索树）改进的树形排序完整实现，包含详细的注释和测试代码。

### 红黑树原理概述

红黑树是一种自平衡二叉搜索树，具有以下性质：
1. 每个节点是红色或黑色
2. 根节点是黑色
3. 每个叶子节点（NIL）是黑色
4. 红色节点的子节点必须是黑色
5. 从任一节点到其每个叶子的所有路径包含相同数目的黑色节点

这些性质保证了红黑树在最坏情况下的高度为O(log n)，从而保证操作效率。

#### 完整C++实现

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <algorithm>

// 节点颜色枚举
enum class Color { RED, BLACK };

// 红黑树节点结构
struct RBTreeNode {
    int val;
    Color color;
    std::shared_ptr<RBTreeNode> left;
    std::shared_ptr<RBTreeNode> right;
    std::shared_ptr<RBTreeNode> parent;
    
    // 构造函数
    RBTreeNode(int x) : val(x), color(Color::RED), 
                       left(nullptr), right(nullptr), parent(nullptr) {}
};

// 红黑树类
class RBTree {
private:
    std::shared_ptr<RBTreeNode> root;
    std::shared_ptr<RBTreeNode> nil; // 哨兵节点，表示NIL叶子节点

    // 左旋
    void leftRotate(std::shared_ptr<RBTreeNode> x) {
        auto y = x->right;
        x->right = y->left;
        
        if (y->left != nil) {
            y->left->parent = x;
        }
        
        y->parent = x->parent;
        
        if (x->parent == nil) {
            root = y;
        } else if (x == x->parent->left) {
            x->parent->left = y;
        } else {
            x->parent->right = y;
        }
        
        y->left = x;
        x->parent = y;
    }

    // 右旋
    void rightRotate(std::shared_ptr<RBTreeNode> y) {
        auto x = y->left;
        y->left = x->right;
        
        if (x->right != nil) {
            x->right->parent = y;
        }
        
        x->parent = y->parent;
        
        if (y->parent == nil) {
            root = x;
        } else if (y == y->parent->right) {
            y->parent->right = x;
        } else {
            y->parent->left = x;
        }
        
        x->right = y;
        y->parent = x;
    }

    // 插入后修复红黑树性质
    void insertFixup(std::shared_ptr<RBTreeNode> z) {
        while (z->parent->color == Color::RED) {
            if (z->parent == z->parent->parent->left) {
                auto y = z->parent->parent->right;
                if (y->color == Color::RED) {
                    // 情况1：叔节点是红色
                    z->parent->color = Color::BLACK;
                    y->color = Color::BLACK;
                    z->parent->parent->color = Color::RED;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->right) {
                        // 情况2：叔节点是黑色且z是右孩子
                        z = z->parent;
                        leftRotate(z);
                    }
                    // 情况3：叔节点是黑色且z是左孩子
                    z->parent->color = Color::BLACK;
                    z->parent->parent->color = Color::RED;
                    rightRotate(z->parent->parent);
                }
            } else {
                // 对称情况
                auto y = z->parent->parent->left;
                if (y->color == Color::RED) {
                    z->parent->color = Color::BLACK;
                    y->color = Color::BLACK;
                    z->parent->parent->color = Color::RED;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->left) {
                        z = z->parent;
                        rightRotate(z);
                    }
                    z->parent->color = Color::BLACK;
                    z->parent->parent->color = Color::RED;
                    leftRotate(z->parent->parent);
                }
            }
        }
        root->color = Color::BLACK;
    }

    // 中序遍历辅助函数
    void inOrderHelper(std::shared_ptr<RBTreeNode> node, std::vector<int>& result) const {
        if (node != nil) {
            inOrderHelper(node->left, result);
            result.push_back(node->val);
            inOrderHelper(node->right, result);
        }
    }

public:
    // 构造函数
    RBTree() {
        nil = std::make_shared<RBTreeNode>(0);
        nil->color = Color::BLACK;
        root = nil;
    }

    // 插入节点
    void insert(int val) {
        auto z = std::make_shared<RBTreeNode>(val);
        auto y = nil;
        auto x = root;
        
        while (x != nil) {
            y = x;
            if (z->val < x->val) {
                x = x->left;
            } else {
                x = x->right;
            }
        }
        
        z->parent = y;
        if (y == nil) {
            root = z;
        } else if (z->val < y->val) {
            y->left = z;
        } else {
            y->right = z;
        }
        
        z->left = nil;
        z->right = nil;
        z->color = Color::RED;
        insertFixup(z);
    }

    // 中序遍历
    std::vector<int> inOrderTraversal() const {
        std::vector<int> result;
        inOrderHelper(root, result);
        return result;
    }
};

/**
 * 基于红黑树的树形排序
 * @param arr 待排序数组
 */
void rbTreeSort(std::vector<int>& arr) {
    RBTree tree;
    
    // 构建红黑树
    for (int num : arr) {
        tree.insert(num);
    }
    
    // 中序遍历获取排序结果
    arr = tree.inOrderTraversal();
}

int main() {
    // 测试数据
    std::vector<int> arr = {5, 3, 7, 2, 4, 6, 8, 1, 9, 0};
    
    // 打印排序前的数组
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 调用红黑树排序
    rbTreeSort(arr);
    
    // 打印排序后的数组
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 性能测试
    std::vector<int> largeArr(10000);
    std::generate(largeArr.begin(), largeArr.end(), []() {
        return rand() % 100000;
    });
    
    std::cout << "对10000个元素进行排序..." << std::endl;
    rbTreeSort(largeArr);
    std::cout << "排序完成，检查前10个结果: ";
    for (int i = 0; i < 10; ++i) {
        std::cout << largeArr[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### 关键实现细节

1. **哨兵节点(NIL)**：
   - 所有叶子节点都指向同一个NIL哨兵节点
   - 简化边界条件处理

2. **旋转操作**：
   - `leftRotate`和`rightRotate`维护树结构
   - 保持二叉搜索树性质

3. **插入修复**：
   - 处理三种情况维护红黑树性质
   - 确保树保持平衡

4. **内存管理**：
   - 使用`shared_ptr`自动管理内存
   - 避免内存泄漏

#### 复杂度分析

1. **时间复杂度**：
   - 插入单个元素：O(log n)
   - 构建红黑树：n × O(log n) = O(n log n)
   - 中序遍历：O(n)
   - 总复杂度：O(n log n)

2. **空间复杂度**：
   - 存储树结构：O(n)
   - 递归栈深度：O(log n)

#### 与普通BST排序比较

1. **平衡性**：
   - 红黑树保证平衡，避免退化成链表
   - 普通BST最坏情况O(n²)

2. **性能稳定**：
   - 红黑树在各种输入下保持O(n log n)
   - 普通BST对有序输入性能差

3. **实现复杂度**：
   - 红黑树实现更复杂
   - 普通BST实现简单

#### 扩展功能

可以进一步扩展实现以下功能：
1. **删除操作**：实现完整的红黑树删除和修复
2. **迭代器**：支持STL风格的迭代器
3. **模板化**：支持泛型数据类型
4. **多线程安全**：添加线程安全支持

这个实现提供了完整的红黑树排序功能，保证了最坏情况下的O(n log n)时间复杂度，适合需要稳定高效排序的场景。









## 鸡尾酒排序

鸡尾酒排序（Cocktail Sort）是冒泡排序的一种变体，也称为**双向冒泡排序**或**搅拌排序**。它与传统冒泡排序的不同之处在于：
- 冒泡排序只从左到右比较交换元素
- 鸡尾酒排序则是**从左到右和从右到左交替进行**

### 算法步骤

1. **从左到右遍历**：像冒泡排序一样，比较相邻元素，如果左边大于右边就交换，将最大的元素放到最右端
2. **从右到左遍历**：反向比较相邻元素，如果右边小于左边就交换，将最小的元素放到最左端
3. **交替进行**：重复以上两步，逐渐缩小未排序范围，直到数组完全有序

### 性能分析

- **时间复杂度**：
  - 最坏情况：O(n²)（逆序数组）
  - 最好情况：O(n)（已排序数组）
  - 平均情况：O(n²)

- **空间复杂度**：O(1)（原地排序）

- **稳定性**：稳定排序（相等元素不交换）

### 优势与不足

**优势**：
- 对部分有序数组效率高于普通冒泡排序
- 能更快地将小元素移动到正确位置

**不足**：
- 仍然具有O(n²)的平均时间复杂度
- 实际应用中效率仍低于快速排序等高级算法

### C++实现代码（带详细注释）

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 用于std::swap

/**
 * 鸡尾酒排序实现
 * @param arr 待排序的数组引用
 */
void cocktailSort(std::vector<int>& arr) {
    bool swapped = true;  // 标记是否发生交换
    int start = 0;        // 未排序部分的起始索引
    int end = arr.size() - 1; // 未排序部分的结束索引
    
    // 只要在上一轮中有交换发生，就继续排序
    while (swapped) {
        swapped = false; // 重置交换标志
        
        // 从左到右的遍历（类似冒泡排序）
        for (int i = start; i < end; ++i) {
            if (arr[i] > arr[i + 1]) {
                std::swap(arr[i], arr[i + 1]);
                swapped = true; // 发生了交换
            }
        }
        
        // 如果没有发生交换，说明数组已经有序
        if (!swapped) {
            break;
        }
        
        swapped = false; // 重置交换标志
        --end; // 最右侧元素已就位，缩小未排序范围
        
        // 从右到左的遍历（反向冒泡）
        for (int i = end - 1; i >= start; --i) {
            if (arr[i] > arr[i + 1]) {
                std::swap(arr[i], arr[i + 1]);
                swapped = true; // 发生了交换
            }
        }
        
        ++start; // 最左侧元素已就位，缩小未排序范围
    }
}

int main() {
    // 测试数据
    std::vector<int> arr = {5, 1, 4, 2, 8, 0, 2};
    
    // 打印排序前的数组
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 调用鸡尾酒排序
    cocktailSort(arr);
    
    // 打印排序后的数组
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### 代码执行过程示例

以数组 `[5, 1, 4, 2, 8, 0, 2]` 为例：

1. **第一轮从左到右**：
   - 比较交换后：[1, 4, 2, 5, 0, 2, 8]（最大值8归位）
   
2. **第一轮从右到左**：
   - 比较交换后：[0, 1, 4, 2, 2, 5, 8]（最小值0归位）

3. **第二轮从左到右**：
   - 比较交换后：[0, 1, 2, 4, 2, 5, 8]（次大值5归位）

4. **第二轮从右到左**：
   - 比较交换后：[0, 1, 2, 2, 4, 5, 8]（次小值1归位）

5. **第三轮检查**：没有发生交换，排序完成

#### 关键点解析

1. **双向遍历**：
   - 奇数轮从左到右冒泡最大元素
   - 偶数轮从右到左冒泡最小元素

2. **提前终止**：
   - `swapped`标志检测是否已完成排序
   - 没有交换发生时立即终止循环

3. **范围缩小**：
   - `start`和`end`指针逐渐向中间靠拢
   - 每次遍历后缩小未排序范围

#### 优化方向

1. **记录最后交换位置**：
   - 可以记录最后一次交换的位置
   - 下次遍历只需到该位置即可

2. **结合其他算法**：
   - 对小数组使用插入排序
   - 对基本有序数组效果更好

3. **并行化**：
   - 可以尝试并行处理两个方向的比较

### 与其他排序算法比较

1. **与冒泡排序比较**：
   - 鸡尾酒排序对某些特定数据模式更快
   - 两者时间复杂度相同
   - 鸡尾酒排序移动小元素更快

2. **与插入排序比较**：
   - 插入排序对基本有序数组更高效
   - 鸡尾酒排序实现更简单

鸡尾酒排序适合教学目的和小规模数据排序，实际应用中更高效的排序算法（如快速排序、归并排序）通常更为常用。
